\newcommand{\popasm}{\emph{PopAsm}}
\newcommand{\nasm}{\emph{NASM}}
\newcommand{\tasm}{\emph{TASM}}

\documentclass[a4paper,draft,12pt]{book}
\title{\popasm\ --- The Popular Assembler\\User's Manual}
\author{Helcio B. de Mello}
\date{\today}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\pagenumbering{roman}

\bf{NOTE:} This is but a draft of the \popasm\ User's Manual. The
contents of this document may change as needed, until the release
of the first official full version. Comments on English mistakes
or contents are welcome, given the author's native language is not
English. Please see appendix \ref{CONTACT} for contacting info.

\chapter*{About this document}
This document is part of \popasm, the Popular Assembler Project.
It has been totally written in \LaTeX\ by
\popasm\ author himself.

At the time of this writing, \popasm\ had two manuals:

\begin{itemize}
\item{User's Manual} --- this document. It is aimed to those who wish
to use \popasm, regardless the way
it was developed and its internal implementation. This document also
concerns about instalation procedures.
\item{Programmer's Guide} --- documents \popasm\ source code in
detail. It is recommended to those who
want to read, understand and/or modify \popasm\ sources.
\end{itemize}

Please check which manual is the one intended for your needs.

\include{author}
\include{acks}

\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage

\pagenumbering{arabic}
\part{Getting Started}
The first chapters of this manual explain what \popasm\ is, how
to compile and install it, and how to run it, changing its default
behavior as needed.

\chapter{Introduction}
\popasm\ stands for ``Popular Assembler''. It is an assembler,
that is, and assembly language compiler\footnote{Technically
speaking, assemblers are not compilers. They translate lines of code
into machine language in a one-to-one basis. Compilers
translate each line of code into several machine instructions. However,
from this point on, this document will use both
terms (compiler and assembler) indistinctly.}. Its objective is to
convert human readable code into machine instructions.
These instructions will then be either executed as binary programs or
linked with other modules (possibly written in
other languages) to yield a computer program.

Many assemblers already exist. Some are free and open source, others
are not. Some will offer you features that others
will not. Some will be suited for your needs, but others will not.
\popasm\ was designed to gather in a single
assembler the best features of the existing assemblers, yet adding its
own improvements and remaining compatible with
existing code as well. As a result, most of your legacy code can be
compiled under \popasm\ without any modifications
at all.

Besides the benefits discussed so far, \popasm\ is a free open
source project written in ANSI C++, which means
that anyone can read its source code, modify, and compile it anywhere
an ANSI C++ compiler is available. Its peculiar
features make it suited for nearly any assembly programming project:

\begin{itemize}
   \item{Huge numbers internal representation} allows assembly-time
expression evaluation in both integer and floating
point format without any practical limit;
   \item{Smart default options} make your code cleaner, without the
redundancy demanded by some other assemblers;
   \item{Top flexibility} gives the developers the choice to use the
infamous ``red tape'' present in some assemblers
or just write the good old raw assembly code;
   \item{Compatibility with existing code} eases migration to
\popasm\ from other assemblers. There is no need to edit your code;
\popasm\ is compatible with \tasm\ and \nasm.
   \item{And more...}
\end{itemize}

Due to the reasons discussed above, this assembler was named the
``Popular Assembler''. The next sections comment the two main
assemblers \popasm\ is compatible with.

\section{Notes on \tasm}
\tasm\ is not free software. It is also DOS/Windows only, and
took some time to get the instructions of the new processors
included. Such delay possibly contributed the creation of macros
that assembled those missing instructions. Nevertheless, there
seems to be lots of code written for \tasm\ around.

\popasm\ is an attempt to offer the advantages discussed throughout
this document without forcing people to rewrite their code by hand
or throw it away. This means that \popasm\ can be seen as a superset
of \tasm\footnote{Actually, only the most used features are supported.
Additional \tasm\ features may be added as users request them.}.
Such major feature may boost people to give \popasm\ a try. If it
is not of their liking, trying \popasm\ did not change their legacy
code anyway, so there's very little to lose.

\section{Notes on \nasm}
\nasm\ is a free and portable assembler, and that's good. It looks
like many people use \nasm\ today, but there are several points
where \nasm\ can be questioned\footnote{The objective of this section
is to comment \nasm\ under technical criteria, not to hurt anyone's
feelings. All free software must be respected, regardless of its
suitability to any project requirements.}.

Besides being incompatible with existing code, \nasm\ does not
provide (due its design) any typechecking feature for variables;
the developer is obliged to remember the type of each variable
himself. Some people may argue that this is not a big problem,
but as a project grows in size, remembering each variable type
may become nearly impossible.

It can be even worse when a team of developers is working on
the same project. Unless they use a rigid (and redundant)
naming scheme, things will get messy quickly. Using such
assembler for small projects (say, less than 1,000 lines of
code) may be an acceptable idea; doing so for a large project
may lead to disaster. C++ or Java are strongly typed languages;
just imagine how it would be if they did not perform type checking...

Another key point is the absence of good assembly-time arithmetics
features, such as huge numbers arithmetics (both integer and floating
point). \popasm\ overcomes such problems as described in this
document. Other points could be mentioned, but the purpose of this
manual is solely to document \popasm\ features, not to point out
problems in other assemblers.

\chapter{Compiling and Installing \popasm}
This chapter explains how to compile and install \popasm\ under
Linux or other UNIX-like platforms and DOS/Windows. If you have
already done that you may skip to the next chapter.

\section{UNIX environments}

This section describes compiling \& installing info under UNIX-like
operating systems (such as Linux).

\subsection{Compiling \popasm\ sources\label{COMPUNIX}}
In order to compile \popasm\ sources, you will need an ANSI C++
compiler and its standard libraries\footnote{For the curious, I
use egcs 2.91.66}. You will also need \popasm\ source code, which
you should already have. If not, please go to
\emph{http://popasm.sourceforge.net/} and download it. You will
get an archive containing the source code to be built.

Unpack it anywhere you like, using the appropriate software (e.g.
if you downloaded a .tar.gz file, you should run
\emph{tar xvzf popasm-x.y.z.tar.gz}, where $x$, $y$ and $z$ are
the version numbers of the package you got). At this point, a
directory containing the source code will be created.

Now, you should enter the directory containing the sources. e.g.
\emph{/tmp/popasm-0.0.1}. Please do not mistake it for something
like \emph{/tmp/popasm-0.0.1/src}. You should be in \popasm\ 
source code root directory, as in the example above.

\popasm\ relies on \emph{Autoconf}\cite{AUTOCONF} and
\emph{Automake}\cite{AUTOMAKE} to probe your system for the
necessary resources and generate the resulting \emph{Makefile}.
This file will tell the \emph{Make}\cite{MAKE} utility how to
compile \popasm\ sources. First, type

\begin{verbatim}
./configure
\end{verbatim}

to perform the necessary checks. If everything is ok, you should have a
\emph{Makefile}. The next step is to compile the sources. Just type

\begin{verbatim}
make
\end{verbatim}

and the \emph{Make} utility will do the rest, but might take a few
minutes. There should be no warnings and no errors. If you got any,
please check whether your compiler is ANSI compliant. If it is,
please let me know (contacting information can be found in appendix
\ref{CONTACT}).

\subsection{Installing \popasm}

There is basically two ways of installing \popasm: either from
the source code or from a RPM file.

\subsubsection{Installing from Source Code}
You should compile \popasm\ as in section \ref{COMPUNIX}. Remain
in the directory where you built \popasm\ and issue the command
(you will need to be \emph{root} to do that):

\begin{verbatim}
make install
\end{verbatim}

This will install the binary file, documentation, etc.

\subsubsection{Installing from RPM files}
The easiest way to install \popasm\ is to use RPM files. Get one from
\emph{http://popasm.sourceforge.net/} if you have not done so yet.
Login as \emph{root} and type:

\begin{verbatim}
rpm -ivh popasm-x.y.z.rpm
\end{verbatim}

replacing $x$, $y$ and $z$ for the appropriate version numbers. That's
it, you're done.

\section{DOS and Windows environments}
To be written.

\subsection{Compiling \popasm\ sources\label{COMPDOS}}
To be written.

\subsection{Installing \popasm}
To be written.

\chapter{Running \popasm\label{CMDLINE}}

The objective of an assembler is to translate assembly language source
files into executable ones. This process is ilustrated in figure \ref{BASICASM}.

\begin{figure}[h]
\begin{center}
\begin{picture}(300, 100)(20,0)
\put (  0, 85){\fbox{Source File 1}}
\put ( 80, 88){\vector(2, -1){50}}
\put (  0, 55){\fbox{Source File 2}}
\put ( 80, 58){\vector(2,  0){50}}
\put ( 30, 25){\vdots}
\put (  0,  0){\fbox{Source File n}}
\put ( 80,  3){\vector(1,  1){50}}
\put (135, 55){\fbox{Assembler}}
\put (200, 58){\vector(2,  0){40}}
\put (245, 55){\fbox{Executable File}}
\end{picture}
\caption{Basic assembly process}
\label{BASICASM}
\end{center}
\end{figure}

However, for large projects it is usually better to assemble each file
separately, and then link their output into the final executable file.
This procedure is sketched in figure \ref{SEPARATEASM}.

\begin{figure}[h]
\begin{center}
\begin{picture}(300, 100)(40,0)
\put (  0, 85){\fbox{Source File 1}}
\put ( 80, 88){\vector(1, 0){30}}
\put (115, 85){\fbox{Assembler}}
\put (180, 88){\vector(1, -1){25}}
\put (  0, 55){\fbox{Source File 2}}
\put ( 80, 58){\vector(1,  0){30}}
\put (115, 55){\fbox{Assembler}}
\put (180, 58){\vector(1,  0){25}}
\put ( 30, 25){\vdots}
\put (  0,  0){\fbox{Source File n}}
\put ( 80,  3){\vector(1,  0){30}}
\put (115,  0){\fbox{Assembler}}
\put (180,  3){\vector(1,  2){25}}
\put (210, 55){\fbox{Linker}}
\put (255, 58){\vector(1,  0){30}}
\put (290, 55){\fbox{Executable File}}
\end{picture}
\caption{Separate assembly process}
\label{SEPARATEASM}
\end{center}
\end{figure}

In this case, the assembler outputs object files (.o or .obj extensions) that
are used by the linker to build the final executable file. Such approach has
the advantage of not reassembling source files that have not changed since the
last build. \emph{Make} utilities such as GNU Make\cite{MAKE} are very useful
in these situations.

As an example, suppose that only \emph{Source File 2} has changed. It is then
reassembled and a new object file for this single source file is created,
overwriting the previous one. This new object file is combined by the linker
with the other ones (which are up to date, because their source files did not
change), yielding the updated version of the executable file. Note that the
files that did not change were not reassembled.

This chapter tackles the usage of \popasm\ under command line. Arguments,
options and environment variables are discussed in detail.

To be continued.

\part{\popasm\ Syntax from the Beginning}

This part documents \popasm\ syntax, starting from the simplest concepts.
Experienced assembly-language programmers are likely to feel compelled to
skip the next few chapters, but are hereby advised not to do so before
reading at least the their introductory paragraphs.

After presenting the basic syntax, its elements are described in great
detail, each in a subsequent chapter. After reading this part, the average
devoloper should be able to use the most common features of \popasm\ easily.

\chapter{Basic Syntax}

One of \popasm's major goals is compatibility with existing code.
\popasm\ syntax is very similar to the ones supported by \tasm\ and
\nasm. This chapter discusses \popasm\ basic syntax. The next chapters
go into more detail in each syntax component (numbers, registers, etc.).

As stated in chapter \ref{CMDLINE}, \popasm\ takes one or more source
files as inputs, each one containing assembly-language statements. These
statements, in turn, have the following general form:

\begin{verbatim}
label:          CMD     arguments               ; comment
\end{verbatim}

where:

\begin{itemize}
\item{\emph{label}} is an identifier that marks an offset into the current
   memory segment, so it can be referenced elsewhere in the code. The colon
   (:) after the label is optional, but recommended, as discussed in section
   \ref{NOTELABEL}.
\item{\emph{CMD}} is either a x86 instruction (such as MOV, ADD, etc.) or a
   \popasm\ internal command (ORG, DB, etc.). Command names are
   case-insensitive (MOV, mov and Mov are all accepted).
\item{\emph{arguments}} is a comma-separated list of arguments for the CMD
   command used in this line. An argument is any sort of \emph{expression}
   (see chapter \ref{EXPR}). Some commands neither require nor accept arguments.
\item{\emph{comment}} is whatever you want to write to make your code easier
   to read and maintain. Comments are placed after a semicolon, and
   \popasm\ ignores them altogether.
\end{itemize}

For example:

\begin{verbatim}
MULTIPLY:       IMUL    CX,BX,5                 ; CX = BX * 5
\end{verbatim}

\noindent is a valid statement. MULTIPLY is a label (followed by the
optional colon), IMUL is a x86 instruction, and CX, BX and 5 are
arguments for the IMUL instruction. The string following the semicolon
is a comment, and is thus ignored.

None of the items above are mandatory, except that you cannot specify
arguments for a command without issuing it first. So,

\begin{verbatim}
                MOV     AX,BX
\end{verbatim}

\noindent is a valid statement, but

\begin{verbatim}
                AX,BX
\end{verbatim}

\noindent is obviously not.

\popasm\ imposes no tabbing restrictions; white spaces and tabs are
ignored. This document uses a 1--17--25--49 tabbing scheme (that is,
labels at column 1, commands at column 17, arguments at column 25 and
comments at column 49).

\section{Notes on labels\label{NOTELABEL}}

Valid labels are strings of letters (a--z or A--Z), digits (0--9) or any
of the following characters:

\begin{center}
\_ @ \$ ?
\end{center}

\noindent except that the first character cannot be a digit, otherwise the
label would be treated as a number, as discussed in chapter \ref{NUMCHAP}.
Also, note that it is not allowed to use \popasm\ reserved words (such as
command names, registers, etc.) as labels.

\popasm\ is by default case-insensitive\footnote{Due to compatibility with
\tasm.}. Such behavior may be changed by command line options and environment
variables (see chapter \ref{CMDLINE}). This document uses uppercase letters.

As already mentioned, the use of a colon after a label is optional,
but recommended. For example, suppose you issue a LODSB command, but
mistype it for LOADSB instead. As a result, the mistyped command would
be treated as an ordinary label, and thus not compiled properly. \nasm\ 
calls these ``orphan labels'', and offers a command line option to
warn you about that.

But let's check the code below:

\begin{verbatim}
I_LOVE_USING_LONG_LABELS_THROUGHOUT_MY_CODE
                LOADSB
                OR      AL,AL
                JNZ     I_LOVE_USING_LONG_LABELS_THROUGHOUT_MY_CODE
\end{verbatim}

The first line is a rather long label, and the developer decided
to place it alone in its line of code. The next line is the mistyped
command. If the developer decides to enable the orphan-label warning,
an annoying message will always bother him, saying the long label
is orphan. Using the colon, this problem is solved.

Another good reason to use the optional colon is to have an additional
mark to make it clear, to the ones reading your code, that the label is,
indeed, a label, instead of, say, a macro name. Of course, this can
also be achieved with an indentation pattern.

Special care should be taken when using a colon after a label that
defines data. The colon should not appear in such circumstances. Please
check chapter \ref{DEFDATA} for a detailed description of this issue.

\chapter{Numbers\label{NUMCHAP}}
\popasm\ accepts numbers in a variety of ways. A number is a sequence
of as many digits as you want\footnote{There is no practical limit to
number sizes in \popasm. If you want to write a 1,000,000-digits long
number, \popasm\ will accept it gladly (well, if you have patience to
type such number...). Some other assemblers are limited to 32-bit
integer operations.} or separators, in any order, except that:

\begin{itemize}
\item{The first digit must be a 0--9 digit\footnote{Note that if the
   first digit is not decimal, \popasm\ (and other assemblers) will treat
   the string as a symbol, not a number. For instance, AH is a register,
   but 0AH is a number (10 in hex notation).}}
\item{All digits must be valid in the number base.} For example, ``3'' is
   not a valid digit in binary notation.
\end{itemize}

A separator is an underline (\_) character that may appear anywhere
among the number digits, except that it cannot be the first character.
They are ignored by \popasm, but help people read long numbers.

Examples:

\begin{itemize}
\item{12345678} is a valid number, because all of its digits are in the
   range 0--9
\item{12\_345\_678} is the same as above. Note how separators play the
   same role as a comma (that is, as a human being would write 12,345,678
   to make it more readable)
\item{12\_34\_5\_67\_\_\_8} also works, and is \emph{exactly} as the
   other two numbers above, despite looking weird and not being very useful.
\item{\_12\_345\_678} is not a number because the first character is not
   a digit.
\item{3241\_7779q} is not an acceptable octal number because ``9'' is not
	a valid digit in octal notation (``q'' here stands for octal. Explained
	later).
\end{itemize}

Typical uses for separators include separating binary fields of bit
records. As an example, let's suppose that a simple communication
protocol uses a byte
 to encode information about a transmission as
follows:

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{c|l}
\hline Bits & Description\\
\hline
6--7 & Package priority (0--3 range)\\
3--5 & Transmitter's ID (0--7 range)\\
0--2 & Receiver's ID (0--7 range)\\
\hline
\end{tabular}
\caption{Encoding of a simple transmission protocol header}
\end{center}
\end{table}
Thanks to the separators, the programmer can now write:

\begin{verbatim}
                         ; p  snd recv
                MOV     AL,11_000_010_B
\end{verbatim}

That is, a priority $p = 11 (binary) = 3$, a sender whose ID is $snd
= 000 (binary) = 0$ and a receiver whose ID is $recv = 010 (binary)
= 2$ are clearly encoded within AL. More complicated examples may
look messy without separators. The B suffix appended to that
number stands for ``binary'', as discussed in the next section.

\section{Using other bases}
As can be seen in the last example, \popasm\ allows one to specify a
number in many bases simply by appending a suffix. Bases and suffixes
supported by \popasm\ are:

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{c|c|l}
\hline Prefix & Base & Valid digits\\
\hline
b, B, y or Y & Binary (base 2)  & 0--1 \\
o, O, q or Q & Octal (base 8)  & 0--7 \\
d, D, t or T & Decimal (base 10)  & 0--9 \\
h or H & Hex (base 16)  & 0--9, A--F and a--f\protect{\footnotemark}\\
\hline
\end{tabular}
\caption{Prefixes and bases}
\end{center}
\end{table}

\footnotetext{Note, however, that the first digit of an hex number
\emph{must} be in 0--9 range, as explained before.}

There are two other ways of declaring a number as hex:

\begin{itemize}
\item{Using the 0x or 0X prefix}, like in C language. If you use this
   prefix, the hex number that follows it does not need to begin with
   a decimal digit, that is, both 0xA and 0x0A are ok.
\item{Using the \$ prefix}, which may be dangerous. Mistaking -\$70 (-70h)
   with \$-70 (current offset minus 70) will surely lead to disaster.
\end{itemize}

It is important to note that if you do not explicitly specify a number
as binary, octal, decimal or hex, \popasm\ will use the current radix
value, which defaults to 10. That is, unless you specify otherwise, all
numbers will be read in decimal notation. See section \ref{RADIXCMD} if
you want to change the default radix.

\section{Real numbers}
Real numbers can be written in two forms:

\begin{itemize}
\item{The usual dot syntax}, like in 1.23, 3.1416, etc. Note that you can
use alternate bases to write real numbers as well. Eg.: 101.01B (5.25 in binary)
\item{Base and exponent}, as in 6.02e-23 (Avogadro\'{}s constant), 8.13e4 (8130),
etc.
\end{itemize}

Unlike some other assembers, \popasm\ can perform assembly-time operations
on both integer and real numbers. Real numbers have no storage limit either.
\popasm\ has also the advantage of neither rounding nor truncating real numbers.
They have their exact values stored as long as possible.

Another key point is that \popasm\ distinguishes between 0.0 and -0.0, because
they have different encodings.

\subsection{Special numbers\label{SPECNUMSEC}}
When converted to binary format, real numbers are encoded in IEEE format, which
is the one used by x86 FPU's. However, some bit patterns have special meaning,
such as NaN's and infinities. The ability of defining such values is very useful
if FPU programming is concerned.

In order to do so, \popasm\ uses the folowing keywords:

\begin{itemize}
\item{INFINITY} --- returns the IEEE encoding for $+\infty$. Because \popasm\ 
supports arithmetics even on such special symbols, -INFINITY can be used to
get $-\infty$ if needed.
\item{QNAN n} --- defines a ``quiet NaN'' that hold value $n$ as its fraction.
$n$ must not be zero (see \cite{FPUMAN} for details).
\item{SNAN n} --- defines a ``signaling NaN'' that hold value $n$ as its fraction.
$n$ must not be zero (see \cite{FPUMAN} for details).
\end{itemize}

Note that all of the above symbols, as well as all real numbers, are encoded
differently, depending on the size of the variable that will hold them. For
example, the 32-bit representation for $+\infty$ is obviously different from
its 64-bit counterpart. \popasm\ detects which size to use based on commands
issued previously (eg. if an INFINITY keyword appears after a DQ command, then
its 64-bit encoding will be used).

The next example shows how those keywords can be used:

\begin{verbatim}
                DD      INFINITY                ;  7F80_0000h
                DQ      -INFINITY               ; 0FFE0_0000_0000_0000h
                DD      QNAN 5                  ;  7FC0_0005h
                DQ      -SNAN 18                ; 0FFE0_0000_0000_0012h
                DD      QNAN 0                  ; Error! QNaN being zero
\end{verbatim}

\chapter{Operators}
\popasm\ can perform several arithmetic operations on numbers and symbols. The
operators currently supported, in increasing order of precedence, are listed in
table \ref{OPTAB}.

Operator precedences are discussed in section \ref{NUMEXPR}.

It is important to note that \popasm\ works with both integer and
real numbers. An operator returns an integer only if all of its
arguments are integers. If at least one of them is real, the result
will be real. All possible combinations are summarized in table
\ref{ARGCOMBTAB}.

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{ccl}
\hline
Precedence & Operator & Description\\
\hline
                   & BYTE & 8-bit qualifier\\
                   & WORD & 16-bit qualifier\\
                   & DWORD & Double WORD --- 32-bit qualifier\\
                   & PWORD & triPle WORD --- 48-bit qualifier\\
                   & FWORD & Far WORD --- Same as PWORD\\
                   & QWORD & Quad WORD --- 64-bit qualifier\\
Lowest             & OWORD & Oct WORD --- 128-bit qualifier\\
                   & TBYTE & Ten-BYTE --- 80-bit qualifier\\
                   & TWORD & Ten-WORD --- Same as TBYTE\protect{\footnotemark}\\
                   & SHORT & 8-bit relative displacement\\
                   & NEAR & 16- or 32-bit relative displacement\\
                   & FAR & 32- or 48-bit relative displacement\\
\hline
                   & OR or $\vert$ & Inclusive or\\
                   & XOR or \^{} & Exclusive or\\
\hline
                   & AND or \& & Boolean AND\\
\hline
                   & + & Addition\\
                   & - (binary) & Subtraction\\
\hline
                   & * & Multiplication\\
                   & / & Division\\
                   & MOD or \% & Remainer (modulus)\\
                   & SHL or $< <$ & Binary Shift left\\
                   & SHR or $> >$ & Binary Shift right\\
                   & SAL and SAR & Arithmetic shifts\\
\hline
                   & NOT or \~{}& One's complement\\
                   & + (unary) & Ignored\\
                   & - (unary) & Negation\\
\hline
                   & : & Segment and offset composition\\
\hline
Highest            & . & Member selection (see chapter \ref{AGGRCHAP})\\
\hline
\end{tabular}
\caption{Operators and their precedence}
\label{OPTAB}
\end{center}
\end{table}

\footnotetext{Due to compatibility with \nasm.}

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{cccl}
\hline
Argument 1 & Argument 2 & Result & Example\\
\hline
Integer & Integer & Integer & 3 + 2 = 5\\
Integer & Real & Real & 3 + 2.0 = 5.0\\
Real & Integer & Real & 3.0 + 2 = 5.0\\
Real & Real & Real & 3.0 + 2.0 = 5.0\\
\hline
\end{tabular}
\caption{Argument types combinations}
\label{ARGCOMBTAB}
\end{center}
\end{table}

The next sections provide additional details about each operator.

\section{Size specifiers\label{SIZESPECSEC}}
Also known as size qualifiers, these are the BYTE, WORD, DWORD,
etc. operators. They allow the developer to specify or override
the size (in bits) of an expression. For example:

\begin{verbatim}
                ADD     [BX],7                  ; Error! Undefined operand size.
                ADD     BYTE [BX],7             ; Add 7 to the byte pointed to by BX
                ADD     WORD [BX],7             ; Add 7 to the word pointed to by BX
\end{verbatim}

The first line generates an error because \popasm\ has no means to
figure out whether the user wants to refer to the byte, word or
dword pointed to by BX. There would be three different instructions
depending on which size specifier were used.

The next example shows how the size specifiers can be used to override the
size of a variable:

\begin{verbatim}
FAR_POINTER     DW      5678h, 1234h

                LDS     SI,DWORD [FAR_POINTER]  ; DS:SI = 1234h:5678h
\end{verbatim}

As can be seen, the \verb@FAR_POINTER@ variable defines two words. Because
\popasm\ provides a type checking mechanism, the LDS instruction will check
whether its second argument is a dword variable. In the example above,
\verb@FAR_POINTER@ is defined as a word, and thus there would be a type
mismatch. To tell \popasm\ you are doing so intentionally, use the size
specifier as in the example. This will instruct \popasm\ to treat
\verb@FAR_POINTER@ as a dword.

The reason why \popasm\ behaves like that is to allow the developer to
concentrate on his programming task instead of trying to remember sizes
of variables. Of course, because \popasm\ never forces people to write
code in any particular way, anyone who likes specifying variable sizes
are allowed to do so anytime.

Note that these size specifiers can be used to control the size of
nearly \emph{any} expressions, as shown below.

\begin{verbatim}
                ADD     EDX,18                  ; Adds 18 to EDX
                ADD     EDX,BYTE 18             ; Same as above
                ADD     EDX,DWORD 18            ; 18 encoded as a dword
\end{verbatim}

The first line can be assembled in two ways. One of them encodes 18
as a byte, while the second form encodes 18 as a dword. Because the
first form is more efficient than the second one, and \emph{the
developer did not explicitly choose any in particular}, \popasm\ uses
the former as default.

In fact, as a general rule, everytime the developer does not require
a particular encoding for an instruction, \popasm\ will use its most
efficient form. That's because we understand that if someone needs an
specific encoding, than this need should be emphasised by the size
specifier. Such approach has the following advantages:

\begin{itemize}
\item The developer does not care about \emph{which} encoding will be
used, except under special circumstances where the instruction format
is critical. Because such cases are very rare, the user can benefit
from the efficiency without having to tell the assembler to generate
the short encoding \emph{everytime}.
\item The developer still has full control over his code, because the
longer encoding can be specified, as in the third line of the example
above. It's better to make people use the specifiers only in those
particular cases instead of requiring them to do so everytime (since
most people prefer the efficient form of the instructions).
\item The code will not depend on command line options to be assembled
correctly, since all critical instructions will be shielded from any
such influence by the size specifiers.
\end{itemize}

It's important to note that \popasm\ will \emph{never} replace an
instruction for another one. For instance, \verb@ADD EAX,1@ will
\emph{never} be replaced by an \verb@INC EAX@ instruction.

Due to compatibility reasons, \popasm\ will accept the qualifiers
``BYTE PTR'' as a sinonym for just ``BYTE'', ``WORD PTR'' as well
as just ``WORD'' and so on.

Note that the size specifiers have a slightly
different meaning than their \nasm\ counterparts. If one assembles
the last example using \nasm, \emph{even using the size specifiers}
the encodings are not guaranteed to be size-specific. That's because
\nasm\ supports optimization levels in command line which may ignore
such size specifiers altogether, unless the developer uses the ``STRICT''
keyword. Such keyword is useless in \popasm\ because if someone cares
about specifying the operand size manually that's because this
someone \emph{wants} that particular encoding, regardless of any
optimization level (may be some critical instruction, for example).
Due to compatibility reasons, however, the ``STRICT'' keyword is
recognized, but ignored. Because of the stronger nature of \popasm\
size specifiers there will be no problem in doing so.

%Another point is how \popasm\ handles nesting size qualifiers. In
%this case, the leftmost size qualifier prevails. This may be useful,
%as shown in the next example:
%
%\begin{verbatim}
%VALUE           EQU     BYTE 18
%
%                MOV     ESI,VALUE               ; Error! Size mismatch.
%                MOV     ESI,DWORD VALUE         ; Ok!
%                MOV     ESI,DWORD BYTE 18       ; Same as above
%\end{verbatim}
%
%Initially, \verb@VALUE@ equals 18 as an 8-bit constant. Further in
%the code, such constant must be written in ESI, which is a 32-bit
%5register. Because the constant has explicitly been defined as a
%byte, the first MOV instruction would cause an error. To prevent this,
%the DWORD qualifier tells \popasm\ that such instruction was issued
%intentionally, and thus the constant is sign-extended to 32 bits.
%The last line shows the same nesting explicitly.

\section{+ and -}
These operators may be either unary or binary; their unary form
have greater precedence. Unary minus change the sign of an expression.
Unary plus performs no operation and exists for completeness.

\section{AND, OR and XOR}
Bitwise boolean operators. They can only be used with integer arguments
(positive or negative). Because numbers have, in theory, infinite bits
to their left (positive numbers may be left padded with zeroes and
negative numbers can be sign-extended with ones), these operators
are affected by the sign of their arguments. Table \ref{BOOLEX} shows
an example of sign influence on bitwise operations. Tables
\ref{ARGBOOLSIGN1}--\ref{ARGBOOLSIGN3} show all possible combinations
of signs, boolean bitwise operations and the way they affect the resulting
sign.

Due to compatibility with \nasm, ``\&'', ``$\vert$'' and ``\^{}'' are also
supported.

\begin{table}
\begin{center}
\begin{tabular}[h]{lrr}
\hline
           &            Decimal &            Binary\\
\hline
Argument 1 &              $-75$ &  $1\cdots 110101$\\
Argument 2 &               $ 3$ &  $0\cdots 000011$\\
\hline
AND Result &                $1$ &  $0\cdots 000001$\\
OR  Result &               $-9$ &  $1\cdots 110111$\\
XOR Result &              $-10$ &  $1\cdots 110110$\\
\hline
\end{tabular}
\caption{Example of bitwise boolean operations on signed numbers}
\label{BOOLEX}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Positive\\
Negative & Positive & Negative\\
\hline
\end{tabular}
\caption{Relation between AND operator and the sign of its arguments}
\label{ARGBOOLSIGN1}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Negative\\
Negative & Negative & Negative\\
\hline
\end{tabular}
\caption{Relation between OR operator and the sign of its arguments}
\label{ARGBOOLSIGN2}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Negative\\
Negative & Negative & Positive\\
\hline
\end{tabular}
\caption{Relation between XOR operator and the sign of its arguments}
\label{ARGBOOLSIGN3}
\end{center}
\end{table}

\section{/ and MOD}
It is not possible to divide by or get the remainer by zero. Also,
the MOD operator \emph{always} return the result with the same sign
of the first argument. For example, \verb@-23 MOD 7 = -2@ and
\verb@23 MOD -7 = 2@.

\nasm\ operators $//$, $\%$ and $\%\%$ are supported for compatibility
reasons.

\section{SHL and SHR}
These operators \bf{always} perform \bf{binary} shifts (i.e. they treat
their arguments as unsigned numbers in two's complement notation). Do
not mistake an SHL operator for the SHL instruction. In the examples
below, the bits shifted in appear delimited by a separator:

\begin{verbatim}
                MOV     AX,101B                 ; AX = 101B here
                SHL     AX,3                    ; SHL instruction
                ; AX SHL 3 = 101B SHL 3 = 101_000B

                MOV     AX,101B SHL 3           ; same as above

                MOV     BL,-50 SHR 3            ; BL = 25
                ; 11001110 SHR 3 = 000_11001
\end{verbatim}

\nasm\ counterparts for these operators ($< <$ and $> >$) are supported
for compatibility reasons. Note, however, that, like \nasm\ and unlike
ANSI C, such operators in \popasm\ always perform binary shifts. If you
need their arithmetic versions, see next section.

Another point to consider is that binary right shifting negative numbers
require their two's complement value to be known. It is not possible to
perform such calculation without fixing the number size in bits. For
example:

\begin{verbatim}
                MOV     AL,-1 SHR 1             ; AL = 127
                MOV     AX,-1 SHR 1             ; AX = 32767
\end{verbatim}

At first glance (without reading the comments), both instructions load
the same value to their destination registers, but because $-1$ is encoded
as $0FFh$ in 8 bits and as $0FFFFh$ in 16 bits, $-1 \ SHR \ 1$ will yield
different results. The second line can be rewritten as:

\begin{verbatim}
                MOV     AX,BYTE -1 SHR 1        ; AX = 127 now
\end{verbatim}

\noindent in order to get the same result for the first line. If the
operand size is omitted, then \popasm\ will get it from the context. As
in the example before, because AX is a 16-bit register $-1$ is encoded
in 16 bits as well.

\section{SAL and SAR}
These operators \bf{always} perform \bf{arithmetic} shifts. Do not
mistake an SAR operator for the SAR instruction. In the examples
below, the bits shifted in appear delimited by a separator:

\begin{verbatim}
                MOV     AX,5                    ; AX = 5 = 101B here
                SAL     AX,3                    ; SAL instruction
                ; AX SAL 3 = 101B SAL 3 = 101_000B

                MOV     AX,5 SAL 3              ; same as above

                MOV     BL,-50 SAR 3            ; BL = -7
                ; 11001110 SAR 3 = 111_11001
\end{verbatim}

The cautious reader should note that SHL and SAL produce the same
results. SAL is supported for completeness only. Note also that SAR
does not depend on the operand size in bits, as SHR does. Repeating
the example of the last section we have:

\begin{verbatim}
                MOV     AL,-1 SAR 1             ; AL = -1 = 255
                MOV     AX,-1 SAR 1             ; AX = -1 = 65535
\end{verbatim}

\section{NOT}
Performs the one´s complement operation (that is, it toggles all bits
of its argument). \verb@NOT@ is both an instruction and an operator.
For example:

\begin{verbatim}
                MOV     AL,5                    ; AL = 5 = 101B here
                NOT     AL                      ; NOT instruction
                ; AL = NOT 5 = NOT 101B = 11111_010B

                MOV     AL,NOT 5                ; same as above
\end{verbatim}

\nasm\ counterpart for this operator, ``\~{}'', is supported for
compatibility reasons.

\chapter{Registers}
\popasm\ supports all registers present in each x86 CPU, except the ones
added in IA-64 architecture (which will be added in a later version):

\begin{itemize}
\item{8-bit general-purpose registers:} AL, BL, CL, DL, AH, BH, CH and DH
\item{16-bit general-purpose registers:} AX, BX, CX, DX, SP, BP, SI and DI
\item{32-bit general-purpose registers:} EAX, EBX, ECX, EDX, ESP, EBP, ESI and EDI
\item{Segment registers:} CS, DS, ES, FS, GS and SS
\item{Control registers:} CR0, CR2, CR3 and CR4
\item{Debug registers:} DR0 thru DR7
\item{Test registers:} TR3 thru TR7
\item{FPU registers:} ST(0) thru ST(7). ST0 thru ST7 are also accepted for
compatibility with \nasm. ST is an alias for ST(0).
\item{MMX registers:} MM0 thru MM7. MM is an alias for MM0.
\item{XMM registers:} XMM0 thru XMM7. XMM is an alias for XMM0.
\end{itemize}

Register names are case insensitive (i.e. AX, ax, aX and Ax are all the
same thing).

\chapter{Constants\label{CONSTCHAP}}
Constants can be used to make code easier to understand and maintain.
There are two kinds of constants supported by \popasm, which are discussed
in the next sections.

\section{Defining constant constants}
Constant constants are assembly-time symbols that hold values that cannot
be changed. This may sound redundant at first, because no constant could
change its value anyway, so there would be no reason to say ``constant
constant''.

This kind of constant can be defined by the EQU command. Its syntax is:

\begin{verbatim}
label           EQU     expression
\end{verbatim}

\noindent where:

\begin{itemize}
\item{\emph{label}} is the name of the constant to be defined. It \emph{must not}
   be followed by a colon. Rules for specifying labels can be found in
   section \ref{NOTELABEL}.
\item{\emph{expression}} is \emph{any} sort of expression. Expressions are
explained in chapter \ref{EXPR}.
\end{itemize}

For example:

\begin{verbatim}
LINE_FEED       EQU     0Ah
BIOS_SIGNATURE  EQU     0AA55h
MAX_RETRIES     EQU     3
\end{verbatim}

The lines of code above define three constants: LINE\_FEED (equal to 0Ah),
BIOS\_SIGNATURE (equal to 0AA55h) and MAX\_RETRIES (equal to 3).

Besides the usual restrictions about defining labels, a constant constant
is not allowed to be redefined. For example:

\begin{verbatim}
MAX_RETRIES     EQU     3                       ; 1st definition
MAX_RETRIES     EQU     4                       ; error! redefined constant
MAX_RETRIES     EQU     3                       ; error! redefined constant
\end{verbatim}

As the third line of the example above shows, constant constants cannot be
redefined even if the value of the new definition is the same as the
previous one.

\section{Defining mutable constants}
Mutable constants are the ones that can be changed (redefined) in
assembly-time. They can be defined (and redefined) by the $=$ operator.
Despite sounding paradoxal, this makes sense, as the next example shows:

\begin{verbatim}
MAX_RETRIES     =       3
; Normal code comes here

MAX_RETRIES     =       10                      ; Redefinition ok.
; Critical code! Must be allowed to retry more times!
\end{verbatim}

That is, the same constant is being used in different parts of the
code. Such freedom may lead to bugs if misused, though. If all constants
are made mutable, one may accidentally redefine it thinking he would
be defining a new one. Because constant constants cannot be redefined,
you will get an error message if you forget about an existing constant
and attempt to redefine it. In short: always use constant constants,
unless you need to redefine it later.

\section{Using constants}
Once a constant is defined, it can be used the way anyone would expect,
as shown below:

\begin{verbatim}
FOO             EQU     5

                MOV     AL,5                    ; AL = 5
                MOV     AL,FOO                  ; Same as above
\end{verbatim}

Note that constants may hold expressions, not just numbers. Let's check
the next example:

\begin{verbatim}
; Stack image of SI register after a PUSHA instruction
STACK_SI        EQU     WORD [BP+2]

                PUSHA                           ;
                MOV     STACK_SI,17h            ; SI = 17h
                POPA                            ;
\end{verbatim}

As can be seen, the MOV instruction altered the contents of the SI
register image in the stack, using the STACK\_SI constant. When \popasm\ 
finds the MOV instruction, it replaces the constant's contents and
assemble the instruction normally.

Another key point is that, because \popasm\ is a multi-pass assembler,
users can reference constants that are defined later on. However, when
dealing with variable constants, special care should be taken. For example:

\begin{verbatim}
                MOV     AL,FOO                  ; AL = 5 or 6?

FOO             =       5
                MOV     BL,FOO                  ; BL = 5

FOO             =       6
                MOV     CL,FOO                  ; CL = 6
\end{verbatim}

That is, when referencing a variable constant that has not been defined yet,
\popasm\ uses the value of the first definition (in this case 5). So, in the
first line above FOO equals to 5.

\chapter{Expressions\label{EXPR}}

An expression may be either a single term or a sequence of terms
connected by operators. A term, in turn, can be a number or a symbol.
This section explains how \popasm\ performs assembly-time arithmetics
and works with expressions.

\section{Numeric expressions\label{NUMEXPR}}
As mentioned in chapter \ref{NUMCHAP}, \popasm\ internally stores numbers
using as many bits as necessary to hold them. As a consequence, the
expression evaluation in \popasm\ benefits from this facility. \popasm\ 
also delays number rounding and truncation as much as possible, avoiding
precision losses and overflows.

For example:

\begin{verbatim}
                MOV     AL,17014018740175480164581h MOD 100h
\end{verbatim}

\noindent is a valid \popasm\ statement, because the expression on the
second argument of the MOV instruction evaluates to 81h, which lies in
the 00h-FFh range, and thus can be written into AL. Note that the first
term of the expression is clearly larger than the 32-bit maximum value,
and could cause an overflow in other assemblers.

Numeric terms may be either numbers or numeric constants (see chapter
\ref{CONSTCHAP}). Also, operators execute in decreasing order of precedence.
If two or more operators have the same precedence, they are executed from
left to right. If necessary, parenthesis may be used to alter the evaluation
sequence. There is no limit for parenthesis nesting. See table \ref{OPTAB}
for a list of operators and their precedences.

The code below shows some examples of expression evaluation.

\begin{verbatim}
FOO             EQU     -37
BAR             EQU      7
MINUS_ONE       EQU     -1

; MINUS_ONE is always equal to -1, but -1 is encoded as 0FFh, 0FFFFh, etc.
; depending on the operand size expected. That is, -1 = 0FFh for the DB
; command, -1 = 0FFFFh for the DW command and so on.
                DB      MINUS_ONE >> 4          ; 0Fh
                DW      MINUS_ONE >> 4          ; 0FFFh
                DD      MINUS_ONE >> 4          ; 0FFF_FFFFh
                DQ      MINUS_ONE >> 4          ; 0FFF_FFFF_FFFF_FFFFh

; Arithmetic shift examples. Note that only the final results are
; converted to two's complement.
                DB      FOO SAR 2               ; -10 = 0F6h
                DW      FOO SAR 2               ; -10 = 0FFF6h
                DD      FOO SAR 2               ; -10 = 0FFFF_FFF6h
                DQ      FOO SAR 2               ; -10 = 0FFFF_FFFF_FFFF_FFF6h

; Shows how parenthesis can be used to alter the evaluation sequence.
; Because AL must be in [-128, +127] or [0, 255], we have an error in
; the second line.
                MOV     AL,-FOO + 5 * BAR       ; AL = 6
                MOV     AL,(FOO + 5) * BAR      ; AL = -182 <- Error!

; Signed and unsigned division. -37 = 219 because BL is 8 bits wide.
                MOV     BL,FOO / 5              ; BL = -7 = 0F9h
                MOV     BL,FOO // 5             ; BL = 43

; Same as above, but -37 = 65499 because BX is 16 bits wide.
                MOV     BX,FOO / 5              ; BX = -7 = 0FFF9h
                MOV     BX,FOO // 5             ; BX = 13099

; Signed and unsigned remainer. -37 = 219 because BL is 8 bits wide.
; In the fourth line, -5 = 251
                MOV     BL,FOO % 5              ; BL = -2 = 0FEh
                MOV     BL,FOO %% 5             ; BL = 4
                MOV     BL,-FOO % -5            ; BL = 2
                MOV     BL,-FOO %% -5           ; BL = 219
\end{verbatim}

\section{Memory references}
Memory references can be specified using square brackets [ ] around an expression.
For instance:

\begin{verbatim}
                MOV     AX,[1234]
\end{verbatim}

\noindent writes the word pointed to by $1234$ into AX. In this case, DS is used as the
default segment register. If you wanted to use another segment register (say,
ES), you would write:

\begin{verbatim}
                MOV     AX,ES:[1234]
                MOV     AX,[ES:1234]            ; same as above
\end{verbatim}

This latter form was added for compatibility with \nasm\ and \tasm\ ideal mode.
This document uses the former syntax throughoutly, though.

\subsection{Weak and strong memory references}
Programmers usually need to store data in variables. Those variables can then
be referenced by their names. For example, if VAR is a word variable, its
contens can be copied into CX by the following command:

\begin{verbatim}
                MOV     CX,VAR                  ; CX = VAR's contents
\end{verbatim}

Unfortunately, different assemblers may give different meanings to the line
of code above. \tasm\ behaves as described here, but \nasm\ would place the
variable's offset into CX instead. Because the name of a variable may be
treated both as its contents and its offset (depending on the assembler
being used), such memory references will be called \bf{weak memory references}
in \popasm\ documentation.

\popasm\ behaves as described above (a variable's name means its contens, \bf{not}
its offset.) with respect to weak memory references. If you wish to refer to
a variable's offset, you should use the \emph{OFFSET} keyword. The example
above would be rewritten as:

\begin{verbatim}
                MOV     CX,OFFSET VAR           ; CX = VAR's offset
\end{verbatim}

On the other hand, a \bf{strong memory reference} is always enclosed within a
pair of matching square brackets. Example:

\begin{verbatim}
                MOV     CX,[VAR]                ; CX = VAR's contents
\end{verbatim}

The reader is advised to avoid using weak memory references, for their
meaning is assembler-dependant. Instead, whenever you refer to a variable's
offset, you should use the \emph{OFFSET} keyword, and whenever you want to
reference the variable's contents, a strong memory reference is the best
choice. Doing that way, your code will rely neither on \popasm's default
behavior, nor the presence/absence of command-line options.

\subsection{Additional memory references}
\popasm\ has full support to all syntaxes for referencing memory
in both 16- and 32-bit modes. For the next example, \verb@TABLE@ is an
array of words:

\begin{verbatim}
                MOV     AX,[ES:TABLE+BX+SI+10]  ; like NASM
                MOV     AX,ES:TABLE[BX+SI+10]   ; same as above
                MOV     AX,ES:TABLE[BX][SI][10] ; same as above

                MOV     AX,TABLE[4]             ; AX = 3rd word of the array
                MOV     AX,[TABLE+4]            ; same as above
\end{verbatim}

The first three lines perform the same action. The fourth line is accepted
due to compatibility with \tasm, despite looking confusing at first glance.
The fifth line does the same as the fourth one, but looks better.

\popasm\ always encode memory displacements the most efficient way.
Use size qualifiers if you need to change this behavior. For example:

\begin{verbatim}
                MOV     AX,[BX+5]               ; Efficient encoding
                MOV     AX,[BX+BYTE 5]          ; same as above
                MOV     AX,[BYTE BX+5]          ; same as above

                MOV     AX,[BX+WORD 5]          ; Forces 16-bit displacement
                MOV     AX,[WORD BX+5]          ; same as above
\end{verbatim}

The first line encodes the displacement (5) as a byte by default. The
next line does the same thing, as third one, supported because of
compatibility  with \nasm. The next two lines force the displacement
being encoded as a word. 

It is also possible to force a null displacement being encoded as
a byte or word. See the next example:

\begin{verbatim}
                MOV     AX,[BX]                 ; No displacement

                MOV     AX,[BX+BYTE 0]          ; Forces a null 8-bit displacement
                MOV     AX,[BYTE BX]            ; same as above

                MOV     AX,[BX+WORD 0]          ; Forces a null 16-bit displacement
                MOV     AX,[WORD BX]            ; same as above

                INC     BYTE [WORD BX]          ; Increments the byte pointed to by BX. Uses a zero 16-bit displacement.
                INC     BYTE [BX+WORD 0]        ; same as above
                INC     WORD [BYTE BX]          ; Increments the word pointed to by BX. Uses a zero 8-bit displacement.
                INC     WORD [BX+BYTE 0]        ; same as above
\end{verbatim}

The first line has no displacement; the second one forces a zero
dummy displacement being encoded as a byte. The third line does
the same, despite looking weird (supported due to compatibility
with \nasm). The fourth and fifth lines use a null 16-bit dummy
displacement. In 32-bit mode, the displacement may be encoded as
either a byte or a dword.

The last four lines are there as a warning: one must be careful
when using \nasm\ syntax for dummy displacements. The size qualifier
inside the square brackets specify the size of the displacement,
not the size of the variable being referenced.

The next example shows some memory access in 32-bit mode:

\begin{verbatim}
                MOV     AX,TABLE[ECX*2]         ; Encoded as TABLE[ECX+ECX]
                MOV     AX,TABLE[NOSPLIT ECX*2] ; Encoded as TABLE

                MOV     AX,TABLE[ECX+EDX]       ; ECX is base
                MOV     AX,TABLE[EDX+ECX]       ; EDX is base

                MOV     AX,DS:TABLE[EBP+ECX]    ; Optimizeable
                MOV     AX,SS:TABLE[ECX+EBP]    ;

DS:             MOV     AX,TABLE[EBP+ECX]       ; Non-optimizeable

                DS:                             ; Same as above
                MOV     AX,TABLE[EBP+ECX]       ;

\end{verbatim}

The memory reference of the first line is encoded as \verb@TABLE[ECX+ECX]@.
Such behavior can be avoided using the \emph{NOSPLIT} keyword, borrowed from
\nasm, as in the second line.

The third and fourth lines look equal, but there is a slight difference
betwwen them: in the third line, ECX is the base register and EDX is the
index one. In the fourth line, the role of ECX and EDX are exchanged.
Whenever possible, the first register will always be encoded as a base
register and the second one as the index register within the SIB.

The next two lines illustrate an exception to that rule. If EBP is used
as the base register, the default segment register for that memory access
would be SS. Conversely, if ECX is used as the base register, DS will be
the default segment register, allowing the segment prefix in the fifth
line to be skipped. Likewise, in the sixth line, exchanging the order of
the registers inside the brackets will make SS the default segment register,
turning the explicit segment override prefix redundant. By default,
\popasm\ performs such optimizations automatically, but they can be disabled
as shown in Chapter \ref{CMDLINE}.

It is more common, however, to disable such optimization for a single critical
line of code, as in the seventh line, where the segment prefix appears to be
a label\footnote{As with labels, the colon is optionsl.}. Such syntax forces
\popasm\ to write the segment prefix and to leave the registers inside the
brackets in their given order. The eigth and ninth lines show an alternative
way of doing so.

\chapter{Defining data\label{DEFDATA}}
This chapter shows how to allocate static storage for variables and, if
desirable, give them an initial value. The general syntax for definig data
is:

\begin{verbatim}
label:          DEF_CMD expression_list
\end{verbatim}

\noindent where:

\begin{itemize}
\item \verb@label@ is the name of the variable to be defined. It is optional,
as well as the colon following it.
\item \verb@DEF_CMD@ is a definition command (see below).
\item \verb@expression_list@ is a comma-separated sequence of expressions.
Such expressions determine the initial value of the variable. If the developer
wants to define uninitialized data, the special value ``?'' may be used instead.
\end{itemize}

The definition command may be any of the following:

\begin{itemize}
\item DB --- Define Byte: defines 8-bits integer variables.
\item DW --- Define Word: defines 16-bits\footnote{Regardless of whether the assembler
is in 16- or 32-bits mode} integer variables.
\item DD --- Define Double word: defines 32-bits integer or floating point variables.
\item DP --- Define triPle word: defines 48-bit integer variables, often used to store
a 48-bits far pointer (16 bits due to segment; 32 bits due offset).
\item DF --- Define Far word: same as DP. Included in \popasm\ for compatibility with \tasm.
\item DQ --- Define Quadruple word: defines 64-bits integer or floating point variables.
\item DT --- Define Ten bytes: defines a 80-bits floating point variable or an 80-bits
integer packed BCD variable.
\item DO --- Define Octuple word: defines 128-bits XMM data.
\end{itemize}

For example:

\begin{verbatim}
FOO             DB     1, 2, 3
                DW     123 + 456, 1234h, ?, -175
NEGATIVE_ZERO   DD     -0.0
ENTRY_POINT     DD     07C0h:0000h
FAR_ADDRESS     DP     1234h:56789ABCh
HUGE_VALUE      DQ     INFINITY
\end{verbatim}

The first line defines FOO as a byte variable. It allocates three bytes in a row and
assign them the 1, 2 and 3 initial values. The second line defines no variable at all,
but allocates four words just after the last byte defined in the first line. Note that
the third word is undefined and that any numeric expression can be accepted as initial
value. The next line defines a double word (32 bits) variable named NEGATIVE\_ZERO,
initialized to the IEEE representation for -0.0. The fourth and fifth lines define a
double and a triple word , but they store a full pointer instead of a sinple integer.
The last line encodes the IEEE representation for $+\infty$ (see Section \ref{SPECNUMSEC}).

\section{DUP expressions}
Sometimes it is necessary to allocate large amounts of memory. There is a special
operator for that purpose: the \emph{DUP} operator. It can only be used within
definition statements. Its role is to duplicate a sequence of expressions. For example:

\begin{verbatim}
FOO             DB      0, 0, 0, 0, 0           ; 5 null bytes
BAR             DB      5 DUP (0)               ; same as above
\end{verbatim}

The parenthesis surrounding the expression to be duplicated are optional. There is
a pitfall regarding their use, shown below:

\begin{verbatim}
FOO             DB      4 DUP (0, 1)            ; defines 8 bytes
FOO2            DB      0, 1, 0, 1, 0, 1, 0, 1  ; same as above

BAR             DB      4 DUP 0, 1              ; defines 5 bytes
BAR2            DB      0, 0, 0, 0, 1           ; same as above
\end{verbatim}

Note that only the expressions inside parenthesis are duplicated. If they are not
used, the DUP operator will act only on the first one, as showm in defining BAR
variable.

DUP expressions can also be nested:

\begin{verbatim}
                DB      2 DUP (1, 2, 2 DUP 3)   ; defines 8 bytes
                DB      1, 2, 3, 3, 1, 2, 3, 3  ; same as above
\end{verbatim}

\section{Label variables}
It is not necessary to allocate any storage to define a variable. In case one
needs to define a variable wothout reserving any memory space, the keyword
\verb@LABEL@ may be used. Its syntax is:

\begin{verbatim}
VARIABLE_NAME   LABEL   type
\end{verbatim}

\noindent where

\begin{itemize}
\item \verb@VARIABLE_NAME@ is the name of the variable to be defined.
\item \verb@type@ is one of the size specifiers discussed in Section
\ref{SIZESPECSEC}.
\end{itemize}

For example:

\begin{verbatim}
INFO_START      LABEL   BYTE                    ; Marks beginning of INFO
LENGTH          DD      35.8                    ;
WIDTH           DD      12.5                    ; Some stuff here...
HEIGTH          DD      80.1                    ;
INFO_END        LABEL   BYTE                    ; Marks end of INFO

INFO_LENGTH     EQU     INFO_END - INFO_START   ; Total storage for INFO
\end{verbatim}

\section{Reserving storage}
In order to achieve compatibility with \nasm, \popasm\ also supports
the RESB, RESW, ..., etc. directives. They are used in the BSS section
of a module to allocate uninitialized memory. Their syntax is:

\begin{verbatim}
LABEL           RES_CMD qty
\end{verbatim}

\noindent where

\begin{itemize}
\item \verb@LABEL@ is the variable to be defined (optional). It may be
followed by an optional colon.
\item \verb@RES_CMD@ is any of the RESB, RESW, ..., etc. commands.
\item \verb@qty@ is the number of bytes, words, etc. to reserve.
\end{itemize}

For example:

\begin{verbatim}
STACK1          RESD    1024                    ; reserve 1024 dwords
BUFFER          RESB    32768                   ; reserve 32768 bytes
\end{verbatim}

\section{Notes on labels}
One of the greatest features of \popasm\ is its type checking mechanism.
When one defines a variable as a word, the assembler will keep track of
that and will issue error messages when it finds type mismatchs, unless
the developer uses a type specifier (see Section \ref{SIZESPECSEC}) to
explicitly override a variable's type.

Note, however, that in order to achieve compability with \tasm, all
labels followed by the optional colon will be treated as code labels
(that is, a label one can JMP to). For example:

\begin{verbatim}
ENTRY_POINT:    DW      OFFSET FUNCTION         ; Watch out!
ENTRY_POINT2    DW      OFFSET FUNCTION         ; Ok.

                .
                .
                .

                JMP     ENTRY_POINT             ; Disaster!
                JMP     [ENTRY_POINT]           ; Ok.
                JMP     ENTRY_POINT2            ; Better.
\end{verbatim}

The first label, ENTRY\_POINT, is defined as a code label. the JMP
instruction will transfer the CPU execution to its offset, \bf{NOT}
to its contens, unless the square brackets are used. Note that code
labels have no type at all, so if ENTRY\_POINT were a far pointer
instead of a near one the wrong instruction would be generated.

ENTRY\_POINT2 is defined using the recommended syntax. Because no
colon is used, \popasm\ assigns the proper typing info to that
variable, so the last line will generate the correct instruction.

In order to avoid this pitfall, the developer may follow a simple
rule: use the colon \emph{only} if the symbol is a code label.
Because defining such labels does not require a colon, one may
choose not to use it at all.

The reader might wonder why \popasm\ does not keep track of the
typing info even when the colon is used. The reason for that is
that some assemblers did not recognize recent instructions (such
as earlier versions of \tasm.). The developer, then, was forced
to encode some instructions manually. For example, if an assembler
does not recognize the EMMS instruction then someone could encode
it this way:

\begin{verbatim}
SOME_LABEL:     DW      77FFh                   ; EMMS

                .
                .
                .

                JMP     SOME_LABEL              ; Ok.
\end{verbatim}

If \verb@SOME_LABEL@ were treated as an ordinary variable the JMP
instruction would jump to address 0FF77h instead of the desired
target.

\part{\popasm\ Advanced Syntax}
This part presents advanced \popasm\ features, including commands and macros
that one might never use, but are here anyway due to the compatibiliy guideline
that drove \popasm\ so far.

\chapter{Aggregates\label{AGGRCHAP}}
This chapter discusses the three ways a developer may aggregate several data
fields into a single data unit, which can be manipulated easier than disjoint
variables spread everywhere. Another good reason to pack data this way is
that your code will become easier to read and maintain without any execution
performance loss.

\section{STRUCT}
Structures are the simplest aggregates that can be defined. They are a sequence
of data members that are placed in adjacent memory addresses. The syntax for
defining structures is:

\begin{verbatim}
struct_name     STRUCT
FIELD_NAME      DEF_CMD EXPRESSION
FIELD_NAME      DEF_CMD EXPRESSION
.
.
.
FIELD_NAME      DEF_CMD EXPRESSION
ENDS
\end{verbatim}

\noindent where FIELD\_NAME are the names of each field (member), DEF\_CMD is
any of the data defining commands (DB, DW, etc., see Chapter \ref{DEFDATA}) and
EXPRESSION is the default value for the field if it is not specified when the
structure is used (see details further in this section). The ENDS command stands
for ``END Structure''. Also, STRUCT and STRUC are both accepted indistinctly.

For example, let's suppose we want to define a simple structure to hold dates.
Its fields will be month, day and year values:

\begin{verbatim}
DATE_STRUCT     STRUCT
MONTH           DB      6
DAY             DB      5
YEAR            DW      1979
ENDS
\end{verbatim}

Note that the code above defines no data at all; it only defines a structure
that may now be used (instantiated). The syntax for instantiating structure is:

\begin{verbatim}
INSTANCE_NAME   STRUCT_NAME <EXPR1, EXPR2, ..., EXPRN>
\end{verbatim}

The syntax above define a variable named INSTANCE\_NAME, and instantiate the
structure to the expressions given (EXPR1, EXPR2, ..., EXPRN). For example,
if someone wants to use the above structure to define a variable that holds
the date ``Oct 22nd 1977'' then the next line will do it:

\begin{verbatim}
IMPORTANT_DATE  DATE_STRUCT <10, 20 + 2, 1977>
\end{verbatim}

As can be seen, the first expression (10) will be placed in the first field of
the structure (MONTH), the second expression, which evaluates to 22 (just to
remind that any numeric expression can be used, not just numbers), will be copied
to the next field and so on. The original default values of the structure definition
remain unchanged. The next example shows how to use those default values:

\begin{verbatim}
JOHN            DATE_STRUCT <2, 7, 1977>
MARY            DATE_STRUCT <5, 1, 1975>
LINDA           DATE_STRUCT < ,  , 1981>
\end{verbatim}

Here, we define three dates. The last one looks incomplete, but the blanks will
be filled by their default values (MONTH = 6 and DAY = 5). The blank spaces
between the commas and the left angle bracket are optional, but were included
to give the code a better look.

Once a structure is instantiated, its fields can be accessed as any other
variable using the field selection operator (.). Using the structures used
in the last example, one could write \verb@JOHN.MONTH@ to refer to the byte
related to MONTH in JOHN variable. Other examples follow:

\begin{verbatim}
                MOV     AL,[JOHN.DAY]           ; AL = 7

                MOV     BX,OFFSET JOHN.DAY      ; Same as above
                MOV     AL,[BX]                 ;

                MOV     BX,OFFSET JOHN          ;
                MOV     SI,OFFSET DATE_STRUCT.DAY; Same as above
                MOV     AL,[BX+SI]              ;

                MOV     [DATE_STRUCT.DAY],19    ; Wrong!
\end{verbatim}

The first line copies the contents of the DAY field of the JOHN variable
(declared as a DATE\_STRUCT in the previous example) into AL. The same
thing could have been achieved by pointing BX to that field (as in the
second line) and using that register as a pointer to the field. Another
variant of this approach is to use two pointers: one pointing to the
variable being referenced and the other to the desired field address
(relative to the beginning of the structure).

Such a relative address can be got by specifying the name of the structure,
followed by the period, followed by the field name. In the fifth line
of the last example, \verb@DATE_STRUCT.DAY@ returns the offset of the
\verb@DAY@ field relative to the beginning of the structure. Note that
that offset cannot be used to access memory, given it does not point to
any structure in particular. That's why the last line of the example
above is wrong.

As a final remark, because the fields of structures occupy memory addresses
individually, the total size of a structure is the sum of the sizes of all
its fields. This value can be returned by the \verb@SIZE@ keyword. For
example, \verb@SIZE DATE_STRUCT@ returns 4 (DAY and MONTH occupy one byte
each, plus two bytes due to the YEAR field).

\section{UNION\label{SECUNION}}
Unions are like structures, except that all of its fields are placed in the
same memory address. Writing to one of its fields thus modifies all of them,
given the shared memory nature of the union.

The syntax for declaring a union is similar to the one for structures,
except that the \verb@STRUCT@ keyword is replaced for \verb@UNION@. Note,
however, that because unions fields occupy the same memory location it
is possible to specify a default value for \emph{at most} one of their
fields. For example:

\begin{verbatim}
EXAMPLE         UNION
BYTE_FIELD      DB      ?
WORD_FIELD      DW      ?
DWORD_FIELD     DD      1234_5678h
ENDS            ; Yes, unions are ended with ENDS, not ENDU
\end{verbatim}

Unions fields are accessed the same way as the fields of a structure (via
the period operator). The offsets of their fields are referred by the
same means as with structures, but keep in mind that the offset of all
fields are the same as the offset of the union variable itself. Considering
the union defined above:

\begin{verbatim}
INSTANCE        EXAMPLE <, 4321h,>
INSTANCE2       EXAMPLE <, 4321h, 123>          ; Error!

                MOV     AL,INSTANCE.BYTE_FIELD  ; AL = 21h
                MOV     AL,BYTE INSTANCE        ; same as above
                MOV     EAX,INSTANCE.DWORD_FIELD; EAX = 1234_4321h
\end{verbatim}

\noindent That it, the default value for the \verb@DWORD_FIELD@ is used
and then it's least significant word is overriden by the specification of
the second field. The second line is not correct because it attempts to
initialize two fields at the same time, which is not allowed.

Some developers may claim that unions are useless. In fact, one can define
a single variable as the largest field of the union. Then, using size
specifiers it would be possible to access the variable as one with a
different size. For example, let's suppose someone wishes to create a variable
that emulates the EAX register. That could be accomplished this way:

\begin{verbatim}
EMULATED_EAX    DD      0

                MOV     [EMULATED_EAX],EAX
                MOV     WORD [EMULATED_EAX],AX
                MOV     BYTE [EMULATED_EAX],AL
                MOV     BYTE [EMULATED_EAX+1],AH
\end{verbatim}

That is, a single dword emulates EAX and when the AL, AH or AX emulated
counterparts need to be accessed, a size specifier overrides the original
size of the variable. In the last line, the person must also remember to
add 1 to the base offset because AH lies in the second least significant
byte in EAX. Needless to say, this is too error prone. An example of how
structures and unions can be used to provide a safer solution is shown in
Section \ref{NESTSEC}.

\section{RECORD}
To be written.

\section{Nesting Aggregates\label{NESTSEC}}
Aggregates can be nested as well. They behave as a field of the aggregate
that contains them. For example, let's suppose we wish to rewrite the
EAX simulation code (shown in Section \ref{SECUNION}) using nested aggregates.
The EAX register can be seen as the union of a dword (EAX itself), a word
(AX) and two bytes (AH and AL).

The problem is that AH and AL do not share the same storage. Instead, they
should be combined into a 16-bits data unit, which will be one of the fields
of the union. The code below does exactely that.

\begin{verbatim}
; AL and AH must be combined in a 16-bits data unit
AX_STRUCT       STRUCT
SIMULATED_AL    DB      ?
SIMULATED_AH    DB      ?
ENDS

EAX_UNION       UNION
SIMULATED_EAX   DD      ?
SIMULATED_AX    DW      ?
SIMULATED_AH_AL AX_STRUCT       <,>
ENDS

EAX_CLONE       EAX_UNION <0,,>

                MOV     AL,EAX_CLONE.SIMULATED_AH_AL.SIMULATED_AL
                MOV     AH,EAX_CLONE.SIMULATED_AH_AL.SIMULATED_AH
                MOV     AX,EAX_CLONE.SIMULATED_AX
                MOV     EAX,EAX_CLONE.SIMULATED_EAX
\end{verbatim}

The code above first defines a structure to mimic AX lower and upper
bytes. This structure is then used as a field of the \verb@EAX_UNION@,
occupying the same memory space as \verb@SIMULATED_EAX@ itself. Note
that a major drawback of this approach is that the user cannot simply
write \verb@EAX_CLONE.SIMULATED_AL@ because \verb@EAX_UNION@ does not 
have such a field. Instead, it should be written
\verb@EAX_CLONE.AX_STRUCT.SIMULATED_AL@, which is too awkward.

There is a way to remedy that situation, though. If the structure is
defined ``on the fly'' its namespace will merge with the union's one
(for details about namespaces, see Section \ref{NAMESPACESEC}).
The example above can be rewritten as:

\begin{verbatim}
EAX_UNION       UNION
SIMULATED_EAX   DD      ?
SIMULATED_AX    DW      ?

                STRUCT                          ;
SIMULATED_AL    DB      ?                       ; Structure defined
SIMULATED_AH    DB      ?                       ; on the fly
ENDS                                            ;

ENDS

EAX_CLONE       EAX_UNION <,,>

                MOV     AL,EAX_CLONE.SIMULATED_AL
                MOV     AH,EAX_CLONE.SIMULATED_AH
                MOV     AX,EAX_CLONE.SIMULATED_AX
                MOV     EAX,EAX_CLONE.SIMULATED_EAX
\end{verbatim}

\section{Namespace considerations\label{NAMESPACESEC}}
As a project grows in size, there are likely to be many variables,
structures and unions defined throughout the code. This implies
that there is a greater probability of name clashes occur (that
is, an attempt to define a symbol whose name is already being
used by another symbol definition).

The reason why many compilers complain about name clashes is to
avoid ambiguity when such names are referenced. Unfortunatelly
some assemblers are just too rigid in this constraint. For
example, consider the code below:

\begin{verbatim}
NAME            DB      'John Adams', 0

STUDENT         STRUCT
NAME            DB      50 DUP (0)
AGE             DB      ?
ENDS

EMPLOYEE        STRUCT
NAME            DB      50 DUP (0)
SALARY          DD      ?
ENDS

CHARLIE         STUDENT <'Charlie Smith', 12>
DAVE            EMPLOYEE <'Dave Thompson', 4000.00>

                MOV     DX,OFFSET NAME
                MOV     DX,OFFSET CHARLIE.NAME
                MOV     DX,OFFSET DAVE.NAME
\end{verbatim}

As can be seen, a variable \verb@NAME@ appears three times there.
It has a stand-alone version (defined as John Adams), and it is
also a field in both structures.

The first MOV instruction copies the offset of \verb@NAME@ to DX,
but which \verb@NAME@? In \popasm, because nothing more has being
said so far, the stand-alone version is used. The second MOV
instruction makes it clear it refers to the field of the \verb@STUDENT@
structure (given \verb@CHARLIE@ is a student in this code). The
third MOV instruction has no ambiguity either, because it specifies
the \verb@NAME@ in question is a field on EMPLOYEE structure.

The code above is accepted by \popasm\ but some other assemblers
claim there is a name clash in that code. The reason why \popasm\ 
sees no ambiguity in the example above is that it defines a separate
namespace for each existing segment, structure, union and record
\footnote{Note, however, that aggregates defined on the fly have
their namespace intentionally merged with the one of the aggregate
that contains it. See Section \ref{NESTSEC}}.

Because \popasm\ must also be compatible with existing code, there
are means to force the use of a global namespace for all symbols. See
Chapter \ref{CMDLINE} for details. The code below illustrates this
problem:

\begin{verbatim}
STUDENT         STRUCT
NAME            DB      50 DUP (0)
AGE             DB      ?
ENDS

                MOV     AX,OFFSET AGE           ; Not good
                MOV     AX,OFFSET STUDENT.AGE   ; Better
\end{verbatim}

The first MOV instruction relies on the fact that \verb@AGE@ lies
in a global namespace. Such a statement would be treated as an
error, unless \popasm\ is configured to use the global namespace.
The second MOV instruction shows the prefered way of doing what
the line before it does in other assemblers.

\chapter{Macros}
This chapter shows how macros can be defined and used. A macro is
like a procedure, but there is a main difference: macros are
expanded (``interpreted'') at assembly time; procedures are
executed at run-time.

Macros can be seen as an implicit way of performing ``cut-and-paste''
of portions of code or data. Some of them are built-in and ready
for use. Others are defined by the developer.

\section{Built-in macros}
The suported built-in macros are described in the next subsections.

\subsection{REPT --- REPeaT}
This macro allows one to repeat a block of statements several times.
It's syntax is:

\begin{verbatim}
REPT n
                Block of statements
ENDM
\end{verbatim}

\noindent where $n$ is the number of times the block of statements
must be repeated. It can be any numeric expression that evaluates to
an integer number greater than or equal to zero. Note that if $n$
equals to zero the block will be ignored. Example:

\begin{verbatim}
REPT 10
                DB      1
                DB      2, 3
ENDM

                DB      10 DUP (1, 2, 3)        ; Same as above
\end{verbatim}

This macro also supports nesting, that is, it is allowed to use REPT
inside another REPT block.

\subsection{TIMES --- repeat $n$ TIMES}
Use this macro to repeat \emph{a single statement} several times.
If you need to repeat several statements use the REPT macro instead.
Its syntax is:

\begin{verbatim}
TIMES n         statement
\end{verbatim}

\noindent where $n$ is the number of times the statement must be
repeated. It can be any numeric expression that evaluates to an
integer number greater or equal to zero. Note that if $n$ equals
to zero the statement will be ignored. Example:

\begin{verbatim}
TIMES 10        DB      1, 2, 3
                DB      10 DUP (1, 2, 3)        ; Same as above
\end{verbatim}


\section{Defining your own macros}
Because \popasm\ is compatible with \tasm\ and \nasm, both syntaxes
for defining macros are supported.

\subsection{\tasm\ syntax}
\subsection{\nasm\ syntax}

\appendix

\chapter{\popasm\ commands}
This chapter is a list of all commands supported by \popasm\ (except machine
instructions, summarized in appendix \ref{INSTSUM}) in alphabetic order. If a
command has already been mentioned before in this manual, it will be quickly
summarized here, along with a reference to where it is detailed.

\section{.RADIX\label{RADIXCMD}}
This command allows the developer to change the default radix of numbers
from the point the command is issued until the next .RADIX command or
end-of-file is found. \popasm\ sets the default radix to 10 at the start
of each pass.

\subsection{Syntax}

\begin{verbatim}
                .RADIX  expression
\end{verbatim}

\noindent where \emph{expression} is a constant integer numeric expression
that evaluates to 2, 8, 10 or 16. \emph{expression} cannot be affected by
.RADIX commands, that is, its default radix is always decimal regardless
of previous commands.

\subsection{Examples}

Our first example writes the same number in binary, using the ``B'' suffix
and the .RADIX command.

\begin{verbatim}
BINARY_NUMBER   DB      11000111B             ; 'B' means binary

                .RADIX  2
                ; Numbers default to be binary from now on

BINARY_NUMBER2  DB      11000111              ; same as above

                .RADIX  10
                ; Numbers default to be decimal again

DECIMAL_NUMBER  DD      11000111              ; decimal!
\end{verbatim}

It is still possible to use other bases when the default radix is not
decimal, but special care should be taken when numbers default to be hex.
In the next example, the developer changes the default radix to be 16
and attempts to define a variable whose value is 12 in decimal.

\begin{verbatim}
                .RADIX  16
                ; Numbers default to be hex from now on

AMBIGUOUS       DD      12D                   ; What does 'D' mean?
DECIMAL_NUMBER  DD      12T                   ; 'T' means decimal
HEX_NUMBER      DD      12                    ; 12h
\end{verbatim}

Note that 'D' is a valid digit in hex notation. This means that ``12D''
is interpreted as ``12Dh'', not 12 in decimal notation. In order to
avoid this ambiguity, \popasm\ also accepts ``T'' as a suffix for
decimal notation. It can be used no matter what the current radix is.
The same remarks hold for the binary suffixes ``B'' and ``Y'': ``11B''
is an hex number when the current radix is 16, but ``11Y'' is always
binary.

To be continued.

\chapter{Instruction Set Summary\label{INSTSUM}}
The purpose of this chapter is to summarize all machine instructions of
all CPU's supported by \popasm\ and their valid syntaxes. The reader
should refer to Intel and AMD documentation for further details.

The conventions adopted here are:

\begin{itemize}
\item immed8 --- an 8-bit immediate value
\item signed8 --- a signed 8-bit immediate value
\item unsigned8 --- an unsigned 8-bit immediate value
\item mem - A memory reference
\item reg - a general purpose register
\item xmmreg - an XMM register
\end{itemize}

\section{AAA --- Ascii Adjust after Addition}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAA (No arguments)           AAA
\end{verbatim}

\section{AAD --- Ascii Adjust before Division}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAD (No arguments)           AAD
AAD unsigned8                AAD     16
\end{verbatim}

\subsection{Notes}
\popasm\ does not check whether or not the immediate argument for this
instruction is zero.

\section{AAM --- Ascii Adjust after Multiply}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAD (No arguments)           AAM
AAD unsigned8                AAM     10h
\end{verbatim}

\section{AAS --- ASCII Adjust after Subtraction}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAS (No arguments)           AAS
\end{verbatim}

\section{ADC --- ADd with Carry}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADC reg,reg/mem              ADC     CL,DH
ADC mem,reg                  ADC     [80h],EDX
ADC reg/mem,immed            ADC     [VAR],18
ADC reg/mem,signed8          ADC     EAX,-6
\end{verbatim}

\section{ADD --- ADDition}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADD reg,reg/mem              ADD     CL,DH
ADD mem,reg                  ADD     [80h],EDX
ADD reg/mem,immed            ADD     [VAR],18
ADD reg/mem,signed8          ADD     EAX,-6
\end{verbatim}

\section{ADDPD --- ADD Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDPD xmmreg,xmmreg/mem128   ADDPD   XMM,XMM1
\end{verbatim}

\section{ADDPS --- ADD Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDPS xmmreg,xmmreg/mem128   ADDPS   XMM5,TABLE[ESI]
\end{verbatim}

\section{ADDSD --- ADD Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDSD xmmreg,xmmreg/mem64    ADDSD   XMM5,[EDI+ARRAY]
\end{verbatim}

\section{ADDSS --- ADD Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDSS xmmreg,xmmreg/mem32    ADDSS   XMM3,ES:[BX]
\end{verbatim}

\section{AND --- logical AND}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AND reg,reg/mem              AND     AX,BX
AND mem,reg                  AND     [80h],DL
AND reg/mem,immed            AND     BYTE [GS:WORD_VAR],18
AND reg/mem,signed8          AND     ESI,-6
\end{verbatim}

\section{ANDPD --- bitwise AND Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDPD xmmreg,xmmreg/mem128   ANDPD   XMM7,[EAX]
\end{verbatim}

\section{ANDPS --- bitwise AND Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDPS xmmreg,xmmreg/mem128   ANDPS   XMM0,[ESI*4]
\end{verbatim}

\section{ANDNPD --- bitwise AND Not Packed Double-precision floating-point values}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDNPD xmmreg,xmmreg/mem128  ANDNPD  XMM7,[EAX]
\end{verbatim}

\section{ANDNPS --- bitwise AND Not Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDNPS xmmreg,xmmreg/mem128  ANDNPS  XMM0,[ESI*4]
\end{verbatim}


\section{ARPL --- Adjust RPL field of segment selector}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ARPL reg16/mem16,reg16       ARPL    AX,[BX]
\end{verbatim}

\section{BOUND --- check array index against BOUNDs}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BOUND reg16,mem32            BOUND   AX,[BX]
BOUND reg32,mem64            BOUND   ECX,[FULL_POINTER]
\end{verbatim}

\section{BSF --- Bit Scan Forward}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BSF reg16,reg16/mem16        BSF     CX,SI
BSF reg32,reg32/mem32        BSF     EBX,SS:[SUM]
\end{verbatim}

\section{BSR --- Bit Scan Reverse}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BSR reg16,reg16/mem16        BSR     CX,SI
BSR reg32,reg32/mem32        BSR     EBX,SS:[SUM]
\end{verbatim}

\section{BSWAP --- Byte SWAP}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BSWAP reg32                  BSWAP   EDX
\end{verbatim}

\section{BT --- Bit Test}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BT reg16/mem16,reg16         BT      AX,BX
BT reg32/mem32,reg32         BT      [DI],ECX
BT reg16/mem16,unsigned8     BT      DX,15
BT reg32/mem32,unsigned8     BT      EAX,25
\end{verbatim}

\subsection{Notes}
\popasm\ always checks whether the immediate argument is
valid. The bit number must be lesser than the size in bits
of the first argument. For example, if the first argument
is 16-bits wide the immediate argument must be in the 0--15
interval.

\section{BTC --- Bit Test and Complement}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BTC reg16/mem16,reg16        BTC     AX,BX
BTC reg32/mem32,reg32        BTC     [DI],ECX
BTC reg16/mem16,unsigned8    BTC     DX,15
BTC reg32/mem32,unsigned8    BTC     EAX,25
\end{verbatim}

\subsection{Notes}
\popasm\ always checks whether the immediate argument is
valid. The bit number must be lesser than the size in bits
of the first argument. For example, if the first argument
is 16-bits wide the immediate argument must be in the 0--15
interval.

\section{BTR --- Bit Test and Reset}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BTR reg16/mem16,reg16        BTR     AX,BX
BTR reg32/mem32,reg32        BTR     [DI],ECX
BTR reg16/mem16,unsigned8    BTR     DX,15
BTR reg32/mem32,unsigned8    BTR     EAX,25
\end{verbatim}

\subsection{Notes}
\popasm\ always checks whether the immediate argument is
valid. The bit number must be lesser than the size in bits
of the first argument. For example, if the first argument
is 16-bits wide the immediate argument must be in the 0--15
interval.

\section{BTS --- Bit Test and Set}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
BTS reg16/mem16,reg16        BTS     AX,BX
BTS reg32/mem32,reg32        BTS     [DI],ECX
BTS reg16/mem16,unsigned8    BTS     DX,15
BTS reg32/mem32,unsigned8    BTS     EAX,25
\end{verbatim}

\subsection{Notes}
\popasm\ always checks whether the immediate argument is
valid. The bit number must be lesser than the size in bits
of the first argument. For example, if the first argument
is 16-bits wide the immediate argument must be in the 0--15
interval.

\section{CALL --- CALL procedure}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CALL immed                   CALL    PRINT_NUMBER
CALL reg16/mem16             CALL    BX
CALL reg32/mem32/mem48       CALL    PWORD [SI]
CALL farptr32                CALL    0FFFFh:0000h
CALL farpre48                CALL    1234h:DWORD 5Ch
\end{verbatim}

\subsection{Notes}
When in 16-bits mode \popasm\ expects 16-bits displacements.
Using 32-bits displacements in 16-bits mode requires
an explicit cast. Accordingly, in 32-bits mode all displacements
are encoded in 32-bits, unless they are preceeded by a WORD
size specifier. For example:

\begin{verbatim}
                BITS    16
                CALL    1234h:0FFFFh            ; Ok
                CALL    1234h:10000h            ; Error!
                CALL    1234h:DWORD 10000h      ; Ok!

                BITS    32
                CALL    1234h:5Ch               ; 32-bits offset
                CALL    1234h:WORD 5Ch          ; 16-bits offset
\end{verbatim}

Also, for convenience reasons, as well as for compatibility
with \tasm\ DWORD memory variables are treated as FAR arguments,
in 16-bits mode, unless such an assumption is overriden by a
NEAR distance specifier. DWORD variables hold near address in
32-bits mode, though. For example:

\begin{verbatim}
                BITS    16
DWORD_VAR       DD      ?

                CALL    [DWORD_VAR]             ; 16-bits far call
                CALL    NEAR [DWORD_VAR]        ; 32-bits near call
                CALL    WORD NEAR [DWORD_VAR]   ; 16-bits near call

                BITS    32
DWORD_VAR2      DD      ?

                CALL    [DWORD_VAR2]            ; 32-bits near call
                CALL    FAR [DWORD_VAR2]        ; 16-bits far call
\end{verbatim}

\section{CBW --- Convert Byte to Word}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CBW (no arguments)           CBW
\end{verbatim}

\section{CDQ --- Convert Doubleword to Quadword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CDQ (no arguments)           CDQ
\end{verbatim}

\section{CLC --- CLear Carry flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CLC (no arguments)           CLC
\end{verbatim}

\section{CLD --- CLear Direction flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CLD (no arguments)           CLD
\end{verbatim}

\section{CLFLUSH --- Cache Line FLUSH}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CLFLUSH mem8                 CLFLUSH [VAR]
\end{verbatim}

\subsection{Notes}
If the argument size is not specified \popasm\ assumes
it is a byte variable, so both statements below are ok:

\begin{verbatim}
                CLFLUSH BYTE [BX]
                CLFLUSH [BX]
\end{verbatim}

\section{CLI --- CLear Interrupt flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CLD (no arguments)           CLD
\end{verbatim}

\section{CLTS --- CLear Task Switched flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CLTS (no arguments)          CLTS
\end{verbatim}

\section{CMC --- CoMplement Carry flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMC (no arguments)           CMC
\end{verbatim}

\section{CMOVcc --- Contidional MOVe}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMOVcc reg16,reg16/mem16     CMOVcc  AX,[BX]
CMOVcc reg32,reg32/mem32     CMOVcc  EAX,[BX]
\end{verbatim}

\subsection{Notes}
CMOVcc is a generic name for a set of instructions. The
supported variants are:

\begin{itemize}
\item CMOVA --- Move if above
\item CMOVAE --- Move if above or equal to
\item CMOVB --- Move if below
\item CMOVBE --- Move if below or equal to
\item CMOVC --- Move if carry
\item CMOVE --- Move if equal
\item CMOVG --- Move if greater
\item CMOVGE --- Move if greater or equal
\item CMOVL --- Move if less
\item CMOVLE --- Move if less or equal
\item CMOVNA --- Move if not above
\item CMOVNAE --- Move if not above or equal
\item CMOVNB --- Move if not below
\item CMOVNBE --- Move if not below or equal
\item CMOVNC --- Move if not carry
\item CMOVNE --- Move if not equal
\item CMOVNG --- Move if not greater
\item CMOVNGE --- Move if not greater or equal
\item CMOVNL --- Move if not less
\item CMOVNLE --- Move if not less or equal
\item CMOVNO --- Move if not overflow
\item CMOVNP --- Move if not parity
\item CMOVNS --- Move if not sign
\item CMOVNZ --- Move if not zero
\item CMOVO --- Move if overflow
\item CMOVP --- Move if parity
\item CMOVPE --- Move if parity even
\item CMOVPO --- Move if parity odd
\item CMOVS --- Move if sign
\item CMOVZ --- Move if zero
\end{itemize}

Note that some of them have the same machine opcode (eg. CMOVA is
the same as CMOVNBE).

\section{CMP --- CoMPare two operands}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMP reg,reg/mem              CMP     AX,BX
CMP mem,reg                  CMP     [80h],DL
CMP reg/mem,immed            CMP     BYTE [GS:WORD_VAR],18
CMP reg/mem,signed8          CMP     ESI,-6
\end{verbatim}

\section{CMPPD --- CoMPare Packed Double-precision floating point values}
\begin{verbatim}
Valid Syntaxes                 Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPPD xmmreg,xmmreg,unsigned8  CMPPD   XMM,XMM1,2
CMPPD xmmreg,mem128f,unsigned8 CMPPD   XMM3,OWORD [VAR32],7
\end{verbatim}

\subsection{Notes}
The third argument for this instruction is an unsigned immediate value
ranging from 0 thru 7. \popasm\ will check this and emit an error
message if the third argument lies outside this boundary.

Additionally, \popasm\ accepts the following two-argument alias
for this instruction:

\begin{itemize}
\item CMPEQPD --- EQual. Implied third argument is 0.
\item CMPLTPD --- Less Than. Implied third argument is 1.
\item CMPLEPD --- Less Than or Equal. Implied third argument is 2.
\item CMPUNORDPD --- UNORDered. Implied third argument is 3.
\item CMPNEQPD --- Not EQual. Implied third argument is 4.
\item CMPNLTPD --- Not Less Than. Implied third argument is 5.
\item CMPNLEPD --- Not Less than Equal. Implied third argument is 6.
\item CMPORDPD --- ORDered. Implied third argument is 7.
\end{itemize}

For example, the next two lines of code are assembled the same way:

\begin{verbatim}
                CMPPD   XMM3,XMM,0
                CMPEQPD XMM3,XMM
\end{verbatim}

\section{CMPPS --- CoMPare Packed Single-precision floating point values}
\begin{verbatim}
Valid Syntaxes                 Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPPS xmmreg,xmmreg,unsigned8  CMPPS   XMM,XMM1,2
CMPPS xmmreg,mem128f,unsigned8 CMPPS   XMM3,OWORD [VAR32],7
\end{verbatim}

\subsection{Notes}
The third argument for this instruction is an unsigned immediate value
ranging from 0 thru 7. \popasm\ will check this and emit an error
message if the third argument lies outside this boundary.

Additionally, \popasm\ accepts the following two-argument alias
for this instruction:

\begin{itemize}
\item CMPEQPS --- EQual. Implied third argument is 0.
\item CMPLTPS --- Less Than. Implied third argument is 1.
\item CMPLEPS --- Less Than or Equal. Implied third argument is 2.
\item CMPUNORDPS --- UNORDered. Implied third argument is 3.
\item CMPNEQPS --- Not EQual. Implied third argument is 4.
\item CMPNLTPS --- Not Less Than. Implied third argument is 5.
\item CMPNLEPS --- Not Less than Equal. Implied third argument is 6.
\item CMPORDPS --- ORDered. Implied third argument is 7.
\end{itemize}

For example, the next two lines of code are assembled the same way:

\begin{verbatim}
                CMPPS   XMM3,XMM,0
                CMPEQPS XMM3,XMM
\end{verbatim}

\section{CMPS / CMPSB / CMPSW / CMPSD --- CoMPare Strings}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPS mem8,mem8               CMPS    BYTE [SI],[DI]
CMPS mem16,mem16             CMPS    WORD GS:[SI],[BX]
CMPS mem32,mem32             CMPS    DW_ARRAY,[DI]
CMPSB (no arguments)         CMPSB
CMPSW (no arguments)         CMPSW
CMPSD (no arguments)         CMPSD
\end{verbatim}

\subsection{Notes}
\popasm\ accepts a segment override prefix only for the first argument
of CMPS instruction. Besides that restriction, any memory references are
accepted as arguments, given their operand sizes match as well as their
memory access modes. For example:

\begin{verbatim}
                CMPS    BYTE [SI],WORD [DI]     ; Type mismatch
                CMPS    BYTE [SI],BYTE [EDI]    ; Mode mismatch
                CMPS    BYTE [SI],BYTE GS:[EDI] ; Segment override not ok.
\end{verbatim}

\section{CMPSD --- CoMPare Scalar Double-precision floating point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPPD xmmreg,xmmreg,unsigned8 CMPSD   XMM,XMM1,2
CMPPD xmmreg,mem64f,unsigned8 CMPSD   XMM3,QWORD [VAR32],7
\end{verbatim}

\subsection{Notes}
The third argument for this instruction is an unsigned immediate value
ranging from 0 thru 7. \popasm\ will check this and emit an error
message if the third argument lies outside this boundary.

Additionally, \popasm\ accepts the following two-argument alias
for this instruction:

\begin{itemize}
\item CMPEQSD --- EQual. Implied third argument is 0.
\item CMPLTSD --- Less Than. Implied third argument is 1.
\item CMPLESD --- Less Than or Equal. Implied third argument is 2.
\item CMPUNORDSD --- UNORDered. Implied third argument is 3.
\item CMPNEQSD --- Not EQual. Implied third argument is 4.
\item CMPNLTSD --- Not Less Than. Implied third argument is 5.
\item CMPNLESD --- Not Less than Equal. Implied third argument is 6.
\item CMPORDSD --- ORDered. Implied third argument is 7.
\end{itemize}

For example, the next two lines of code are assembled the same way:

\begin{verbatim}
                CMPSD   XMM3,XMM,0
                CMPEQSD XMM3,XMM
\end{verbatim}

\section{CMPSS --- CoMPare Scalar Single-precision floating point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPSS xmmreg,xmmreg,unsigned8 CMPPS   XMM,XMM1,2
CMPSS xmmreg,mem32f,unsigned8 CMPPS   XMM3,DWORD [VAR],7
\end{verbatim}

\subsection{Notes}
The third argument for this instruction is an unsigned immediate value
ranging from 0 thru 7. \popasm\ will check this and emit an error
message if the third argument lies outside this boundary.

Additionally, \popasm\ accepts the following two-argument alias
for this instruction:

\begin{itemize}
\item CMPEQSS --- EQual. Implied third argument is 0.
\item CMPLTSS --- Less Than. Implied third argument is 1.
\item CMPLESS --- Less Than or Equal. Implied third argument is 2.
\item CMPUNORDSS --- UNORDered. Implied third argument is 3.
\item CMPNEQSS --- Not EQual. Implied third argument is 4.
\item CMPNLTSS --- Not Less Than. Implied third argument is 5.
\item CMPNLESS --- Not Less than Equal. Implied third argument is 6.
\item CMPORDSS --- ORDered. Implied third argument is 7.
\end{itemize}

For example, the next two lines of code are assembled the same way:

\begin{verbatim}
                CMPSS   XMM3,XMM,0
                CMPEQSS XMM3,XMM
\end{verbatim}

\section{CMPXCHG --- CoMPare and eXCHanGe}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPXCHG reg8/mem8,reg8       CMPXCHG FS:[EBP],AH
CMPXCHG reg16/mem16,reg16    CMPXCHG AX,BX
CMPXCHG reg32/mem32,reg32    CMPXCHG [DI],ECX
\end{verbatim}

\section{CMPXCHG8B --- CoMPare and eXCHanGe 8 Bytes}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CMPXCHG8B mem64i             CMPXCHG8B FS:[ECX+EBP*4]
\end{verbatim}

\subsection{Notes}
If the argument size is undefined (as in the example above),
\popasm\ assumes it is a 64-bits variable.

\section{COMISD --- COMpare Scalar ordered Double-precision floating point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
COMISD xmm1,xmm2/mem64       COMISD XMM7,QWORD [MEM32]
\end{verbatim}

\section{COMISS --- COMpare Scalar ordered Single-precision floating point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
COMISS xmm1,xmm2/mem64       COMISS XMM7,QWORD [MEM32]
\end{verbatim}

\section{CPUID --- CPU IDentitication}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CPUID (no arguments)         CPUID
\end{verbatim}

\section{CVTDQ2PD --- ConVerT Packed Doubleword integers to Packed Double precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTDQ2PD xmmreg,xmmreg/mem64 CVTDQ2PD XMM,QWORD [BX]
\end{verbatim}

\section{CVTDQ2PS --- ConVerT Packed Doubleword integers to Packed Single precision floating-point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTDQ2PD xmmreg,xmmreg/mem128 CVTDQ2PD XMM,OWORD [BX]
\end{verbatim}

\section{CVTPD2DQ --- ConVerT Packed Double precision floating-point values to Packed doubleword integers}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPD2DQ xmmreg,xmmreg/mem128 CVTPD2DQ XMM,OWORD [BX]
\end{verbatim}

\section{CVTPD2PI --- ConVerT Packed Double precision floating-point values to Packed Doubleword Integers}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPD2PI xmmreg,xmmreg/mem128 CVTPD2PI XMM,OWORD [BX]
\end{verbatim}

\section{CVTPD2PS --- ConVerT Packed Double precision floating-point values to Packed Single-precision floating-point}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPD2PS xmmreg,xmmreg/mem128 CVTPD2PS XMM,OWORD [BX]
\end{verbatim}

\section{CVTPI2PD --- ConVerT Packed doubleword Integers to Packed Double precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPI2PD xmmreg,xmmreg/mem64 CVTPI2PD XMM,QWORD [BX]
\end{verbatim}

\section{CVTPI2PS --- ConVerT Packed doubleword Integers to Packed Single precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPI2PS xmmreg,xmmreg/mem64 CVTPI2PS XMM,QWORD [BX]
\end{verbatim}

\section{CVTPS2DQ --- ConVerT Packed Single precision floating-point values to Packed doubleword Integers}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPS2DQ xmmreg,xmmreg/mem128 CVTPS2DQ XMM,OWORD [BX]
\end{verbatim}

\section{CVTPS2PD --- ConVerT Packed Single precision floating-point values to Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPS2PD xmmreg,xmmreg/mem64 CVTPS2PD XMM,QWORD [BX]
\end{verbatim}

\section{CVTPS2PI --- ConVerT Packed Single precision floating-point values to Packed doubleword Integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTPS2PI mmxreg,xmmreg/mem64 CVTPS2PI MM,QWORD [BX]
\end{verbatim}

\section{CVTSD2SI --- ConVerT Scalar Double-precision floating-point values to doubleword Integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTSD2SI reg32,xmmreg/mem64  CVTSD2SI ESI,QWORD [BX]
\end{verbatim}

\section{CVTSD2SS --- ConVerT Scalar Double precision floating-point values to Scalar Single-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTSD2SS mmxreg,xmmreg/mem64 CVTSD2SS XMM,QWORD [BX]
\end{verbatim}

\section{CVTSI2SD --- ConVerT doubleword Integer to Scalar Double-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTSI2SD mmxreg,reg32/mem32  CVTSI2SD XMM,DWORD [BX]
\end{verbatim}

\section{CVTSI2SS --- ConVerT doubleword Integer to Scalar Single-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTSI2SS mmxreg,reg32/mem32  CVTSI2SS XMM,DWORD [BX]
\end{verbatim}

\section{CVTSS2SD --- ConVerT Scalar Single precision floating-point value to Scalar Double-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTSS2SD xmmreg,xmmreg/mem32 CVTSS2SD XMM,DWORD [BX]
\end{verbatim}

\section{CVTSS2SI --- ConVerT Scalar Single precision floating-point value to doubleword Integer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTSS2SI xmmreg,xmmreg/mem32 CVTSS2SI EBP,DWORD [BX]
\end{verbatim}

\section{CVTTPD2PI --- ConVerT with Truncation Packed Double-precision floating-point values to Packed doubleword Integers}
\begin{verbatim}
Valid Syntaxes                 Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTTPD2PI mmxreg,xmmreg/mem128 CVTPD2PS MM,OWORD [BX]
\end{verbatim}

\section{CVTTPD2DQ --- ConVerT with Truncation Packed Double-precision floating-point values to Packed doubleword Integers}
\begin{verbatim}
Valid Syntaxes                 Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTTPD2DQ mmxreg,xmmreg/mem128 CVTPD2PS XMM,OWORD [BX]
\end{verbatim}

\section{CVTTPS2DQ --- ConVerT with Truncation Packed Single-precision floating-point values to Packed doubleword Integers}
\begin{verbatim}
Valid Syntaxes                 Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTTPS2DQ xmmreg,xmmreg/mem128 CVTPD2PS XMM,OWORD [BX]
\end{verbatim}

\section{CVTTPS2PI --- ConVerT with Truncation Packed Single-precision floating-point values to Packed doubleword Integers}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTTPS2DQ mmxreg,xmmreg/mem64 CVTPD2PS MM,QWORD [BX]
\end{verbatim}

\section{CVTTSD2SI --- ConVerT with Truncation Scalar Double-precision floating-point value to Signed doubleword Integer}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTTPS2DQ reg32,xmmreg/mem64 CVTPD2PS EDX,QWORD [BX]
\end{verbatim}

\section{CVTTSS2SI --- ConVerT with Truncation Scalar Single-precision floating-point value to doubleword Integer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CVTTPS2DQ reg32,xmmreg/mem32 CVTPD2PS EDX,DWORD [BX]
\end{verbatim}

\section{CWD --- Convert Word to Doubleword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CWD (no arguments)           CWD
\end{verbatim}

\section{CWDE --- Convert Word to Dword in Eax}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
CWDE (no arguments)          CWDE
\end{verbatim}

\section{DAA --- Decimal Adjust after Addition}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DAA (no arguments)           DAA
\end{verbatim}

\section{DAS --- Decimal Adjust after Subtraction}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DAS (no arguments)           DAS
\end{verbatim}

\section{DEC --- DECrement by 1}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DEC reg8/mem8                DEC     CH
DEC reg16/mem16              DEC     WORD [BX]
DEC reg32/mem32              DEC     EBP
\end{verbatim}

\subsection{Notes}
As with most single argument instructions, the size of the
argument must be defined, otherwise \popasm\ will emit an
error message.

\section{DIV --- unsigned DIVide}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DIV reg8/mem8                DIV     CH
DIV reg16/mem16              DIV     WORD [BX]
DIV reg32/mem32              DIV     EBP
\end{verbatim}

\subsection{Notes}
As with most single argument instructions, the size of the
argument must be defined, otherwise \popasm\ will emit an
error message.

\section{DIVPD --- DIVide Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DIVPD xmmreg,xmmreg/mem128   DIVPD   XMM1,OWORD ES:[100h]
\end{verbatim}

\section{DIVPS --- DIVide Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DIVPS xmmreg,xmmreg/mem128   DIVPS   XMM1,OWORD ES:[100h]
\end{verbatim}

\section{DIVSD --- DIVide Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DIVSD xmmreg,xmmreg/mem64    DIVSD   XMM1,QWORD ES:[100h]
\end{verbatim}

\section{DIVSS --- DIVide Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
DIVSS xmmreg,xmmreg/mem64    DIVSS   XMM1,QWORD ES:[100h]
\end{verbatim}

\section{EMMS --- Empty MMx State}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
EMMS (no arguments)          EMMS
\end{verbatim}

\section{ENTER --- make stack frame for procedure parameters}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ENTER unsigned16,unsigned8   ENTER   64,0
\end{verbatim}

\subsection{Notes}
The second argument must be in 0--31 interval. \popasm\ will issue
an error message if the argument is out of that interval.

\section{F2XM1 --- Compute $2^x - 1$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
F2XM1 (no arguments)         F2XM1
\end{verbatim}

\section{FABS --- ABSolute value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FABS (no arguments)          FABS
\end{verbatim}

\section{FADD --- ADD}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FADD mem32f                  FADD    [BRIGHTNESS]
FADD mem64f                  FADD    ES:[LIGHT_SPEED]
FADD ST,fpureg               FADD    ST,ST(1)
FADD fpureg,ST               FADD    ST6,ST0
\end{verbatim}

\section{FADDP --- ADD and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FADDP (no arguments)         FADDP
FADDP fpureg,ST              FADDP   ST(5),ST0
\end{verbatim}

\section{FIADD --- Integer ADD}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FIADD mem16i                 FIADD   [QTY_APPLES]
FIADD mem32i                 FIADD   FS:[POPULATION]
\end{verbatim}

\section{FBLD --- Bcd LoaD}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FIADD mem80bcd               FBLD    [HUGE_VAL]
\end{verbatim}

\section{FBSTP --- Bcd STore and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FBSTP mem80bcd               FBSTP   [HUGE_VAL]
\end{verbatim}

\section{FCHS --- CHange Sign}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCHS (no arguments)          FCHS
\end{verbatim}

\section{FCLEX / FNCLEX --- CLEar eXceptions}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCLEX (no arguments)         FCLEX
FNCLEX (no arguments)        FNCLEX
\end{verbatim}

\section{FCMOVcc --- Floating-point Conditional MOVe}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCMOVcc ST,fpureg            FCMOVcc ST0,ST2
\end{verbatim}

\subsection{Notes}
FCMOVcc actually refers to a set of instructions that
check for different conditions. Suportted variants are:

\begin{itemize}
\item FCMOVB --- Move if below
\item FCMOVE --- Move if equal
\item FCMOVBE --- Move if below or equal
\item FCMOVU --- Move if unordered
\item FCMOVNB --- Move if not below
\item FCMOVNE --- Move if not equal
\item FCMOVNBE --- Move if not below or equal
\item FCMOVNU --- Move if not unordered
\end{itemize}

\section{FCOM --- COMpare}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCOM (no arguments)          FCOM
FCOM fpureg                  FCOM    ST(4)
FCOM mem32f                  FCOM    [SALARY]
FCOM mem64f                  FCOM    [PARSEC]
\end{verbatim}

\section{FCOMP --- COMpare and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCOMP (no arguments)         FCOMP
FCOMP fpureg                 FCOMP   ST(4)
FCOMP mem32f                 FCOMP   [SALARY]
FCOMP mem64f                 FCOMP   [PARSEC]
\end{verbatim}

\section{FCOMPP --- COMpare and Pop twice}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCOMPP (no arguments)        FCOMPP
\end{verbatim}

\section{FCOMI --- COMpare and set eflags}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCOMI ST,fpureg              FCOMI   ST(0),ST(4)
\end{verbatim}

\section{FCOMIP --- COMpare, set eflags and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCOMIP ST,fpureg             FCOMIP  ST(0),ST(4)
\end{verbatim}

\section{FUCOMI --- COMpare, check for ordered and set eflags}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FUCOMI ST,fpureg             FUCOMI  ST(0),ST(4)
\end{verbatim}

\section{FUCOMIP --- COMpare, check for ordered, set eflags and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FUCOMIP ST,fpureg            FUCOMIP ST(0),ST(4)
\end{verbatim}

\section{FCOS --- COSine}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FCOS (no arguments)          FCOS
\end{verbatim}

\section{FDECSTP --- DECrement Stack-Top Pointer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FDECSTP (no arguments)       FDECSTP
\end{verbatim}

\section{FDIV --- DIVide}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FDIV ST,fpureg               FDIV    ST0,ST(4)
FDIV fpureg,ST               FDIV    ST0,ST(4)
FDIV mem32f                  FDIV    [SALARY]
FDIV mem64f                  FDIV    [PARSEC]
\end{verbatim}

\section{FDIVP --- DIVide and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FDIVP (no arguments)         FDIVP
FDIVP fpureg,ST              FDIVP   ST(4),ST
\end{verbatim}

\section{FIDIV --- Integer DIVide}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FIDIV mem16i                 FIDIV   [QTY_APPLES]
FIDIV mem32i                 FIDIV   [POPULATION]
\end{verbatim}

\section{FDIVR --- Reverse DIVide}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FDIVR ST,fpureg              FDIVR   ST0,ST(4)
FDIVR fpureg,ST              FDIVR   ST0,ST(4)
FDIVR mem32f                 FDIVR   [SALARY]
FDIVR mem64f                 FDIVR   [PARSEC]
\end{verbatim}

\section{FDIVP --- Reverse DIVide and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FDIVRP (no arguments)        FDIVRP
FDIVRP fpureg,ST             FDIVRP  ST(4),ST
\end{verbatim}

\section{FIDIV --- Reverse Integer DIVide}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FIDIVR mem32i                FIDIVR  [QTY_APPLES]
FIDIVR mem64i                FIDIVR  [POPULATION]
\end{verbatim}

\section{FEMMS --- Faster Enter/Exit of the MMx or floating-point State}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FEMMS (no arguments)         FEMMS
\end{verbatim}

\section{FFREE --- FREE floating-point register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FFREE fpureg                 FFREE ST6
\end{verbatim}

\section{FICOM --- Integer COMpare}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FICOM mem16i                 FICOM   [QTY_APPLES]
FICOM mem32i                 FICOM   [POPULATION]
\end{verbatim}

\section{FICOMP --- Integer COMpare and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FICOMP mem16i                FICOMP  [QTY_APPLES]
FICOMP mem32i                FICOMP  [POPULATION]
\end{verbatim}

\section{FILD --- Integer LoaD}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FILD mem16i                  FILD    [QTY_APPLES]
FILD mem32i                  FILD    [POPULATION]
FILD mem64i                  FILD    [QTY_STARS]
\end{verbatim}

\section{FINCSTP --- INCrement Stack-Top Pointer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FINCSTP (no arguments)       FINCSTP
\end{verbatim}

\section{FINIT / FNINIT --- INITialize fpu}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FINIT (no arguments)         FINIT
FNINIT (no arguments)        FNINIT
\end{verbatim}

\section{FIST --- STore Integer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FIST mem16i                  FIST    [QTY_APPLES]
FIST mem32i                  FIST    [POPULATION]
\end{verbatim}

\section{FISTP --- STore Integer and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FISTP mem16i                 FISTP   [QTY_APPLES]
FISTP mem32i                 FISTP   [POPULATION]
FISTP mem64i                 FISTP   [QTY_STARS]
\end{verbatim}

\section{FLD --- LoaD floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLD mem32f                   FLD     [SALARY]
FLD mem64f                   FLD     [PARSEC]
FLD mem80f                   FLD     TBYTE [BX]
\end{verbatim}

\section{FLD1 --- LoaD 1}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLD1 (no arguments)          FLD1
\end{verbatim}

\section{FLDL2T --- LoaD $\log_2 10$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDL2T (no arguments)        FLDL2T
\end{verbatim}

\section{FLDL2E --- LoaD $\log_2 e$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDL2E (no arguments)        FLDL2E
\end{verbatim}

\section{FLDPI --- LoaD $\pi$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDPI (no arguments)         FLDPI
\end{verbatim}

\section{FLDLG2 --- LoaD $\log_{10} 2$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDLG2 (no arguments)        FLDLG2
\end{verbatim}

\section{FLDLN2 --- LoaD $\ln 2$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDLN2 (no arguments)        FLDLN2
\end{verbatim}

\section{FLDZ --- LoaD Zero}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDZ (no arguments)          FLDZ
\end{verbatim}

\section{FLDCW --- LoaD Control Word}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDCW mem16                  FLDCW   WORD [BX]
\end{verbatim}

\section{FLDENV --- LoaD fpu ENVironment}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FLDENV  mem112/mem224        FLDENV  [BUFFER]
\end{verbatim}

\subsection{Notes}
Because \popasm\ has no direct support for 112- and 224-bits
data types, \emph{any} memory reference will be accepted as
argument for this command.

\section{FMUL --- MULtiply}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FMUL ST,fpureg               FMUL    ST0,ST(4)
FMUL fpureg,ST               FMUL    ST0,ST(4)
FMUL mem32f                  FMUL    [SALARY]
FMUL mem64f                  FMUL    [PARSEC]
\end{verbatim}

\section{FMULP --- MULtiply and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FMULP (no arguments)         FMULP
FMULP fpureg,ST              FMULP   ST(4),ST
\end{verbatim}

\section{FIMUL --- Integer MULtiply}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FIMUL mem16i                 FIMUL   [QTY_APPLES]
FIMUL mem32i                 FIMUL   [POPULATION]
\end{verbatim}

\section{FNOP --- No OPeration}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FNOP (no arguments)          FNOP
\end{verbatim}

\section{FPATAN --- Partial ArcTANgent}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FPATAN (no arguments)        FPATAN
\end{verbatim}

\section{FPREM --- Partial REMainer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FPREM (no arguments)         FPREM
\end{verbatim}

\section{FPREM1 --- Partial REMainer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FPREM1 (no arguments)        FPREM1
\end{verbatim}

\section{FPTAN --- Partial TANgent}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FPTAN (no arguments)         FPTAN
\end{verbatim}

\section{FRNDINT --- RouND to INTeger}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FRNDINT (no arguments)       FRNDINT
\end{verbatim}

\section{FRSTOR --- ReSToRe fpu state}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FRSTOR mem752/mem864         FRSTOR  [EBP]
\end{verbatim}

\subsection{Notes}
Because \popasm\ has no direct support for 752- and 864-bits
data types, \emph{any} memory reference will be accepted as
argument for this command.

\section{FSAVE / FNSAVE --- SAVE fpu state}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSAVE mem752/mem864          FSAVE   [EBP]
FNSAVE mem752/mem864         FNSAVE  [EBP]
\end{verbatim}

\subsection{Notes}
Because \popasm\ has no direct support for 752- and 864-bits
data types, \emph{any} memory reference will be accepted as
argument for this command.

\section{FSCALE --- Scale}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSCALE (no arguments)        FSCALE
\end{verbatim}

\section{FSIN --- SINe}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSIN (no arguments)          FSIN
\end{verbatim}

\section{FSINCOS --- SINe and COSine}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSINCOS (no arguments)       FSINCOS
\end{verbatim}

\section{FSQRT --- SQuare RooT}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSQRT (no arguments)         FSQRT
\end{verbatim}

\section{FST --- STore floating point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FST fpureg                   FST     ST(2)
FST mem32f                   FST     [SALARY]
FST mem64f                   FST     FS:[STAR_MASS]
\end{verbatim}

\section{FSTP --- STore floating point value and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSTP fpureg                  FSTP    ST(2)
FSTP mem32f                  FSTP    [SALARY]
FSTP mem64f                  FSTP    FS:[STAR_MASS]
FSTP mem80f                  FSTP    GS:[HUGE_VALUE]
\end{verbatim}

\section{FSTCW / FNSTCW --- STore Control Word}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSTCW mem16                  FSTCW   WORD [BX]
FNSTCW mem16                 FNSTCW  WORD [BX]
\end{verbatim}

\section{FSTENV / FNSTENV --- STore fpu ENVironment}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSTENV  mem112/mem224        FSTENV  [BUFFER]
FNSTENV  mem112/mem224       FNSTENV [BUFFER]
\end{verbatim}

\subsection{Notes}
Because \popasm\ has no direct support for 112- and 224-bits
data types, \emph{any} memory reference will be accepted as
argument for this command.

\section{FSTSW / FNSTSW --- STore fpu Status Word}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSTSW   AX                   FSTSW  AX
FSTSW   mem16                FSTSW  [BUFFER]
FNSTSW  AX                   FNSTSW AX
FNSTSW  mem16                FNSTSW [BUFFER]
\end{verbatim}

\section{FSUB --- SUBtract}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSUB mem32f                  FSUB    [BRIGHTNESS]
FSUB mem64f                  FSUB    ES:[LIGHT_SPEED]
FSUB ST,fpureg               FSUB    ST,ST(1)
FSUB fpureg,ST               FSUB    ST6,ST0
\end{verbatim}

\section{FSUBP --- SUBtract and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSUBP (no arguments)         FSUBP
FSUBP fpu_reg,ST             FSUBP   ST(3),ST
\end{verbatim}

\section{FISUB --- Integer SUBtract}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FISUB mem16i                 FISUB   [QTY_APPLES]
FISUB mem32i                 FISUB   FS:[POPULATION]
\end{verbatim}

\section{FSUBR--- Reverse SUBtract}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSUBR mem32f                 FSUBR   [BRIGHTNESS]
FSUBR mem64f                 FSUBR   ES:[LIGHT_SPEED]
FSUBR ST,fpureg              FSUBR   ST,ST(1)
FSUBR fpureg,ST              FSUBR   ST6,ST0
\end{verbatim}

\section{FSUBRP --- Reverse SUBtract and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FSUBRP (no arguments)        FSUBRP
FSUBRP fpu_reg,ST            FSUBRP  ST(3),ST
\end{verbatim}

\section{FISUBR --- Reverse Integer SUBtract}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FISUBR mem16i                FISUBR  [QTY_APPLES]
FISUBR mem32i                FISUBR  FS:[POPULATION]
\end{verbatim}

\section{FTST --- TeST}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FTST (no arguments)          FTST
\end{verbatim}

\section{FUCOM --- Unordered COMpare}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FUCOM (no arguments)         FUCOM
FUCOM fpureg                 FUCOM   ST4
\end{verbatim}

\section{FUCOMP --- Unordered COMpare and Pop}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FUCOMP (no arguments)        FUCOMP
FUCOMP fpureg                FUCOMP  ST4
\end{verbatim}

\section{FUCOMPP --- Unordered COMpare and Pop twice}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FUCOMPP (no arguments)       FUCOMPP
\end{verbatim}

\section{FWAIT --- WAIT}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FWAIT (no arguments)         FWAIT
\end{verbatim}

\section{FXAM --- eXAMine}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FXCH (no arguments)          FXCH
\end{verbatim}

\section{FXCH --- eXCHange register contents}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FXCH (no arguments)          FXCH
FXCH flureg                  FXCH    ST4
\end{verbatim}

\section{FXRSTOR --- ResTORe fpu, mmX, sse and ss2 state}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FXRSTOR mem4096              FXRSTOR ES:[SI]
\end{verbatim}

\subsection{Notes}
Because \popasm\ has no direct support for 4096-bits
data types, \emph{any} memory reference will be accepted as
argument for this command.

\section{FXSAVE --- SAVE fpu, mmX, sse and ss2 state}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FXSAVE mem4096               FXSAVE  ES:[SI]
\end{verbatim}

\subsection{Notes}
Because \popasm\ has no direct support for 4096-bits
data types, \emph{any} memory reference will be accepted as
argument for this command.

\section{FXTRACT --- eXTRACT exponent and significand}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FXTRACT (no arguments)       FXTRACT
\end{verbatim}

\section{FYL2X --- computes $y \times \log_2 x$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FYL2X (no arguments)         FYL2X
\end{verbatim}

\section{FYL2XP1 --- computes $y \times \log_2 (x + 1)$}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
FYL2XP1 (no arguments)       FYL2XP1
\end{verbatim}

\section{HLT --- HaLT}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
HLT (no arguments)           HLT
\end{verbatim}

\section{IDIV --- signed DIVide}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
IDIV reg8/mem8               IDIV    CL
IDIV reg16/mem16             IDIV    WORD FS:[COUNTER]
IDIV reg32/mem32             IDIV    ESI
\end{verbatim}

\section{IMUL --- signed MULtiply}
\begin{verbatim}
Valid Syntaxes                  Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
IMUL reg8/mem8                  IMUL    CL
IMUL reg16/mem16                IMUL    WORD FS:[COUNTER]
IMUL reg32/mem32                IMUL    ESI
IMUL reg16,reg16/mem16          IMUL    BX,GS:[500h]
IMUL reg32,reg32/mem32          IMUL    ESI,EDI
IMUL reg16,reg16/mem16,signed8  IMUL    BX,GS:[500h],-78
IMUL reg32,reg32/mem32,signed8  IMUL    ESI,EDI,13
IMUL reg16,signed8              IMUL    BX,7
IMUL reg32,signed8              IMUL    ESI,-90
IMUL reg16,reg16/mem16,signed16 IMUL    BX,GS:[500h],-78
IMUL reg32,reg32/mem32,signed32 IMUL    ESI,EDI,13
IMUL reg16,signed16             IMUL    BX,200h
IMUL reg32,signed32             IMUL    ESI,12345h
\end{verbatim}

\subsection{Notes}
Because this instruction deals with signed arithmetics, all immediate
values are treated as signed numbers. Thus, the next statements will
cause an error if included in a source file:

\begin{verbatim}
                IMUL    BX,0FFFFh
                IMUL    DX, 8000h
\end{verbatim}

\noindent because the processor would treat \verb@0FFFFh@ as -1 and
\verb@8000h@ as \verb@-8000h@.

\section{IN --- INput from port}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
IN accum,unsigned8           IN      AL,60h
IN accum,DX                  IN      EAX,DX
\end{verbatim}

\section{INC --- INCrement by 1}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
INC reg8/mem8                INC     CH
INC reg16/mem16              INC     WORD [BX]
INC reg32/mem32              INC     EBP
\end{verbatim}

\section{INS / INSB / INSW / INSD --- INput from port to String}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
INS mem8,DX                  INS     BYTE DS:[ESI],DX
INS mem16,DX                 INS     WORD [BX],DX
INS mem32,DX                 INS     DWORD [BUFFER],DX
INSB (no arguments)          INSB
INSW (no arguments)          INSW
INSD (no arguments)          INSD
\end{verbatim}

\section{INT --- call to INTerrupt procedure}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
INT unsigned8                INT     80h
\end{verbatim}

\subsection{Notes}
There is a special single-byte encoding for the \verb@INT 3@ command.
\popasm\ uses that optimized encoding as default, unless the developer
explictly uses a BYTE specifier. Also, for compatibility with \nasm,
\popasm\ also suports its ``INT3'' command (which uses the optimized
encoding). The next example shows all assembly possibilities for the
INT command when its argument's value is 3.

\begin{verbatim}
                INT     3                       ; 1 byte
                INT3                            ; 1 byte
                INT     BYTE 3                  ; 2 bytes
\end{verbatim}

\section{INTO --- INTerrupt of Overflow}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
INTO (no arguments)          INTO
\end{verbatim}

\section{INVD --- INValiDate internal caches}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
INVD (no arguments)          INVD
\end{verbatim}

\section{INVLPG --- INValidate tlb entry}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
INVLPG mem                   INVLPG  GS:[BP+SI]
\end{verbatim}

\section{IRET / IRETD --- Interrupt RETurn}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
IRET (no arguments)          IRET
IRETD (no arguments)         IRETD
\end{verbatim}

\section{Jcc --- Jump if condition is met}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
JCC rel8/rel16/rel32         JCC     NEXT_STEP
\end{verbatim}

\subsection{Notes}
Jcc is actually a reference to a set of instructions where \emph{cc}
is replaced by the condition to test for. Suported variants are:

\begin{itemize}
\item JA --- Jump if Above
\item JAE --- Jump if Above or Equal
\item JB --- Jump if Below
\item JBE --- Jump if Below or Equal
\item JC --- Jump if Carry
\item JE --- Jump if Equal
\item JG --- Jump if Greater
\item JGE --- Jump if Greater or Equal
\item JL --- Jump if Less
\item JLE --- Jump if Less or Equal
\item JNA --- Jump if Not Above
\item JNAE --- Jump if Not Above or Equal
\item JNB --- Jump if Not Below
\item JNBE --- Jump if Not Below or Equal
\item JNC --- Jump if Not Carry
\item JNE --- Jump if Not Equal
\item JNG --- Jump if Not Greater
\item JNGE --- Jump if Not Greater or Equal
\item JNL --- Jump if Not Less
\item JNLE --- Jump if Not Less or Equal
\item JNO --- Jump if Not Overflow
\item JNP --- Jump if Not Parity
\item JNS --- Jump if Not Sign
\item JNZ --- Jump if Not Zero
\item JO --- Jump if Overflow
\item JP --- Jump if Parity
\item JPE --- Jump if Parity Even
\item JPO --- Jump if Parity Odd
\item JS --- Jump if Sign
\item JZ --- Jump if Zero
\end{itemize}

The short version of these instructions is used by default. Whenever the target
is too far for a short jump the near version for the current assembly mode is
then used. Note that this behavior can be changed by size and distance specifiers,
as shown in the next example:

\begin{verbatim}
               JA       $+10                    ; 8-bits displacement

               BITS     16
               JA       NEAR $+10               ; 16-bits displacement
               JA       DWORD $+10              ; 32-bits displacement

               BITS     32
               JA       NEAR $+10               ; 32-bits displacement
               JA       WORD $+10               ; 16-bits displacement
\end{verbatim}

\section{JCXZ / JECXZ --- Jump if CX / ECX is zero}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
JCXZ rel8                    JCXZ    LOOP_EXIT
JECXZ rel8                   JECXZ   LOOP_EXIT
\end{verbatim}

\section{JMP --- JuMP}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
JMP rel8/reg16/rel32         JMP     PROC_EXIT
JMP reg16/mem16              JMP     BX
JMP reg32/mem32/mem48        JMP     PWORD [SI]
JMP farptr32                 JMP     0FFFFh:0000h
JMP farptr48                 JMP     1234h:DWORD 5Ch
\end{verbatim}

\subsection{Notes}
When in 16-bits mode \popasm\ expects 16-bits displacements.
Using 32-bits displacements in 16-bits mode requires
an explicit cast. Accordingly, in 32-bits mode all displacements
are encoded in 32-bits, unless they are preceeded by a WORD
size specifier. For example:

\begin{verbatim}
                BITS    16
                JMP     1234h:0FFFFh            ; Ok
                JMP     1234h:10000h            ; Error!
                JMP     1234h:DWORD 10000h      ; Ok!

                BITS    32
                JMP     1234h:5Ch               ; 32-bits offset
                JMP     1234h:WORD 5Ch          ; 16-bits offset
\end{verbatim}

Also, for convenience reasons, as well as for compatibility
with \tasm\ DWORD memory variables are treated as FAR arguments,
in 16-bits mode, unless such an assumption is overriden by a
NEAR distance specifier. DWORD variables hold near address in
32-bits mode, though. For example:

\begin{verbatim}
                BITS    16
DWORD_VAR       DD      ?

                JMP     [DWORD_VAR]             ; 16-bits far jmp
                JMP     NEAR [DWORD_VAR]        ; 32-bits near jmp
                JMP     WORD NEAR [DWORD_VAR]   ; 16-bits near jmp

                BITS    32
DWORD_VAR2      DD      ?

                JMP     [DWORD_VAR2]            ; 32-bits near jmp
                JMP     FAR [DWORD_VAR2]        ; 16-bits far jmp
\end{verbatim}

\section{LAHF --- Load AH with Flags}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LAHF (no arguments)          LAHF
\end{verbatim}

\section{LAR --- Load Access Rights}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LAR reg16,reg16/mem16        LAR     CX,SI
LAR reg32,reg32/mem32        LAR     EBX,SS:[DWORD_VAR]
\end{verbatim}

\section{LDMXCSR --- Load MXCSR register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LDMXCSR mem32                LDMXCSR [DWORD_VAR]
\end{verbatim}

\section{Lxx --- Load far pointer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LXX reg16,mem32              LXX     CX,[SI]
LXX reg32,mem48              LXX     EBX,ES:[ENTRY_POINT]
\end{verbatim}

\subsection{Notes}
Lxx actually refer to a set of instructions that load far
pointers. Suported variants are:

\begin{itemize}
\item LDS --- Load DS:dest
\item LES --- Load ES:dest
\item LFS --- Load FS:dest
\item LGS --- Load GS:dest
\item LSS --- Load SS:dest
\end{itemize}

\section{LEA --- Load Effective Address}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LEA reg16/reg32,mem16/mem32  LEA     ECX,[EAX + EBX*4 + 200h]
\end{verbatim}

\section{LEAVE --- LEAVE}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LEAVE (no arguments)         LEAVE
\end{verbatim}

\section{LFENCE --- Load FENCE}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LFENCE (no arguments)        LFENCE
\end{verbatim}

\section{LGDT --- Load GDTr}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LGDT mem48                   LGDT    [INITIAL_GDTR]
\end{verbatim}

\section{LIDT --- Load IDTr}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LIDT mem48                   LGDT    [INITIAL_IDTR]
\end{verbatim}

\section{LLDT --- Load LDTr}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LLDT reg16/mem16             LLDT    AX
\end{verbatim}

\section{LMSW --- Load Machine Status Word}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LMSW reg16/mem16             LMSW    AX
\end{verbatim}

\section{LOCK --- assert LOCK signal prefix}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LOCK (no arguments)          LOCK
LOCK statement               LOCK    XCHG    AX,[BX]
\end{verbatim}

\section{LODS / LODSB / LODSW / LODSD --- LOaD String}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LODS mem8/mem16/mem32        LODS    BYTE ES:[ESI]
LODSB (no arguments)         LODSB
LODSW (no arguments)         LODSW
LODSD (no arguments)         LODSD
\end{verbatim}

\section{LOOP / LOOPCC --- LOOP according to cx / ecx}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LOOP rel8                    LOOP    PRINT_STRING
LOOPCC rel8                  LOOPCC  NEXT_STEP
\end{verbatim}

\subsection{Notes}
LOOPCC refers to a set of instructions that test for
particular conditions. Suported variants are:

\begin{itemize}
\item LOOPE --- LOOP if Equal
\item LOOPNE --- LOOP if Not Equal
\item LOOPNZ --- LOOP if Not Zero
\item LOOPZ --- LOOP if Zero
\end{itemize}

\section{LSL --- Load Segment Limits}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LSL reg16,reg16/mem16        LSL     CX,SI
LSL reg32,reg32/mem32        LSL     EBX,SS:[DWORD_VAR]
\end{verbatim}

\section{LTR --- Load Task Register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
LTR reg16/mem16              LTR     CX
\end{verbatim}

\section{MASKMOVDQU --- store selected bytes of Double Quadword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MASKMOVDQU xmmreg,xmmreg     MASKMOVDQU XMM4,XMM1
\end{verbatim}

\section{MASKMOVQ --- store selected bytes of Quadword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MASKMOVQ mmreg,mmreg         MASKMOVQ MM4,MM1
\end{verbatim}

\section{MAXPD --- return MAXimum Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MAXPD xmmreg,xmmreg/mem128   MAXPD   XMM,[OWORD_VAR]
\end{verbatim}

\section{MAXPS --- return MAXimum Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MAXPS xmmreg,xmmreg/mem128   MAXPS   XMM,[OWORD_VAR]
\end{verbatim}

\section{MAXSD --- return MAXimum Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MAXSD xmmreg,xmmreg/mem64    MAXSD   XMM,[QWORD_VAR]
\end{verbatim}

\section{MAXSS --- return MAXimum Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MAXSS xmmreg,xmmreg/mem64    MAXSS   XMM,[DWORD_VAR]
\end{verbatim}

\section{MFENCE --- Memory FENCE}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MFENCE (no arguments)        MFENCE
\end{verbatim}

\section{MINPD --- return MINimum Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MINPD xmmreg,xmmreg/mem128   MINPD   XMM,[OWORD_VAR]
\end{verbatim}

\section{MINPS --- return MINimum Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MINPS xmmreg,xmmreg/mem128   MINPS   XMM,[OWORD_VAR]
\end{verbatim}

\section{MINSD --- return MINimum Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MINSD xmmreg,xmmreg/mem64    MINSD   XMM,[QWORD_VAR]
\end{verbatim}

\section{MINSS --- return MINimum Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MINSS xmmreg,xmmreg/mem64    MINSS   XMM,[DWORD_VAR]
\end{verbatim}

\section{MOV --- MOVe}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOV reg,reg/mem              MOV     AX,BX
MOV mem,reg                  MOV     [80h],DL
MOV reg/mem,immed            MOV     BYTE [GS:WORD_VAR],18
MOV segreg,reg16/mem16       MOV     ES,[2Ch]
MOV reg16/mem16,segreg       MOV     AX,DS
MOV creg/treg/dreg,reg32     MOV     CR0,EAX
MOV reg32,creg/treg/dreg     MOV     ECX,DR5
\end{verbatim}

\subsection{Notes}
It is not possible to MOV to CS.

\section{MOVAPD --- MOVe Aligned Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVAPD xmmreg,xmmreg/mem128  MOVAPD  XMM3,FS:[BP+SI-40]
MOVAPD xmmreg/mem128,xmmreg  MOVAPD  XMM6,XMM2
\end{verbatim}

\section{MOVAPS --- MOVe Aligned Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVAPS xmmreg,xmmreg/mem128  MOVAPS  XMM3,FS:[BP+SI-40]
MOVAPS xmmreg/mem128,xmmreg  MOVAPS  XMM6,XMM2
\end{verbatim}

\section{MOVD --- MOVe Doubleword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVD mmreg,reg32/mem32       MOVD    MM3,DWORD_VAR[ECX*4]
MOVD reg32/mem32,mmreg       MOVD    MM3,MM
MOVD xmmreg,reg32/mem32      MOVD    XMM3,DWORD_VAR[ECX*4]
MOVD reg32/mem32,xmmreg      MOVD    XMM3,XMM
\end{verbatim}

\section{MOVDQA --- MOVe Aligned Double Quadword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVDQA xmmreg,xmmreg/mem128  MOVDQA  XMM3,OWORD_VAR[ECX*4]
MOVDQA xmmreg/mem128,xmmreg  MOVDQA  XMM3,XMM
\end{verbatim}

\section{MOVDQU --- MOVe Unaligned Double Quadword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVDQU xmmreg,xmmreg/mem128  MOVDQU  XMM3,OWORD_VAR[ECX*4]
MOVDQU xmmreg/mem128,xmmreg  MOVDQU  XMM3,XMM
\end{verbatim}

\section{MOVDQ2Q --- MOVe Quadword from xmm to mmx register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVQ2Q mmreg,xmmreg          MOVQ2Q  MM3,XMM4
\end{verbatim}

\section{MOVHLPS --- MOVe Packed Single-precision floating-point values High to Low}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVHLPS xmmreg,xmmreg        MOVHLPS XMM3,XMM4
\end{verbatim}

\section{MOVHPD --- MOVe High Packed Double-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVHPD xmmreg,mem64          MOVHPD  XMM0,[QWORD_VAR]
MOVHPD mem64,xmmreg          MOVHPD  [QWORD_VAR],XMM7
\end{verbatim}

\section{MOVHPS --- MOVe High Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVHPS xmmreg,mem64          MOVHPS  XMM0,[QWORD_VAR]
MOVHPS mem64,xmmreg          MOVHPS  [QWORD_VAR],XMM7
\end{verbatim}

\section{MOVLHPS --- MOVe Packed Single-precision floating-point values Low to High}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVLHPS xmmreg,xmmreg        MOVLHPS XMM3,XMM4
\end{verbatim}

\section{MOVLPD --- MOVe Low Packed Double-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVLPD xmmreg,mem64          MOVLPD  XMM0,[QWORD_VAR]
MOVLPD mem64,xmmreg          MOVLPD  [QWORD_VAR],XMM7
\end{verbatim}

\section{MOVLPS --- MOVe Low Packed Single-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVLPS xmmreg,mem64          MOVLPS  XMM0,[QWORD_VAR]
MOVLPS mem64,xmmreg          MOVLPS  [QWORD_VAR],XMM7
\end{verbatim}

\section{MOVMSKPD --- extract Packed Double-precision floating-point sign mask}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVMSKPD reg32,xmmreg        MOVMSKPD ESI,XMM5
\end{verbatim}

\section{MOVMSKPS --- extract Packed Single-precision floating-point sign mask}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVMSKPS reg32,xmmreg        MOVMSKPS ESI,XMM5
\end{verbatim}

\section{MOVNTDQ --- store Double Quadword using Non-Temporal hint}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVLHPS mem128,xmmreg        MOVLHPS [OWORD_VAR],XMM4
\end{verbatim}

\section{MOVNTI --- store Doubleword using Non-Temporal hint}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVNTI mem32,reg32           MOVNTI  [DWORD_VAR],ESP
\end{verbatim}

\section{MOVNTPD --- store Packed Double-precision floating-point values using Non-Temporal hint}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVNTPD mem128,xmmreg        MOVNTPD XMM_DATA[16],XMM3
\end{verbatim}

\section{MOVNTPS --- store Packed Single-precision floating-point values using Non-Temporal hint}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVNTPS mem128,xmmreg        MOVNTPS XMM_DATA[16],XMM3
\end{verbatim}

\section{MOVNTQ --- store Quadword using Non-Temporal hint}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVNTQ mem128,xmmreg         MOVNTQ  ES:MM_DATA[16],MM3
\end{verbatim}

\section{MOVQ --- MOVe Quadword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVQ mmreg,reg32/mem32       MOVQ    MM3,DWORD_VAR[ECX*4]
MOVQ reg32/mem32,mmreg       MOVQ    MM3,MM
MOVQ xmmreg,reg32/mem32      MOVQ    XMM3,DWORD_VAR[ECX*4]
MOVQ reg32/mem32,xmmreg      MOVQ    XMM3,XMM
\end{verbatim}

\section{MOVQ2DQ --- MOVe Quadword from mmx to xmm Register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVQ2DQ xmmreg,mmxreg        MOVQ2DQ XMM3,MM6
\end{verbatim}

\section{MOVS / MOVSB / MOVSW / MOVSD --- MOVe Strings}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVS mem8,mem8               MOVS    BYTE [DI],[SI]
MOVS mem16,mem16             MOVS    WORD [DI],FS:[BX]
MOVS mem32,mem32             MOVS    DW_ARRAY,[SI]
MOVSB (no arguments)         MOVSB
MOVSW (no arguments)         MOVSW
MOVSD (no arguments)         MOVSD
\end{verbatim}

\subsection{Notes}
\popasm\ accepts a segment override prefix only for the second argument
of MOVS instruction. Besides that restriction, any memory references are
accepted as arguments, given their operand sizes match as well as their
memory access modes. For example:

\begin{verbatim}
                MOVS    BYTE [DI],WORD [SI]     ; Type mismatch
                MOVS    BYTE [DI],BYTE [ESI]    ; Mode mismatch
                MOVS    BYTE GS:[DI],BYTE [ESI] ; Segment override not ok.
\end{verbatim}

\section{MOVSD --- MOVe Scalar Double-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVSD xmmreg,xmmreg/mem64    MOVSD   XMM5,[LIGHT_SPEED]
MOVSD xmmreg/mem64,xmmreg    MOVSD   [QWORD_VAR],XMM4
\end{verbatim}

\section{MOVSS --- MOVe Scalar Single-precision floating-point value}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVSS xmmreg,xmmreg/mem32    MOVSD   XMM5,[SALARY]
MOVSS xmmreg/mem32,xmmreg    MOVSD   [DWORD_VAR],XMM4
\end{verbatim}

\section{MOVSX --- MOVe with Sign-eXtension}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVSX reg16/reg32,reg8/mem8  MOVSX   CX,BYTE [80h]
MOVSX reg32,reg16/mem16      MOVSX   EAX,DX
\end{verbatim}

\section{MOVUPD --- MOVe Unaligned Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVUPD xmmreg,xmmreg/mem128  MOVUPD  XMM3,OWORD_VAR[ECX*4]
MOVUPD xmmreg/mem128,xmmreg  MOVUPD  XMM3,XMM
\end{verbatim}

\section{MOVZX --- MOVe with Zero-eXtension}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVZX reg16/reg32,reg8/mem8  MOVZX   CX,BYTE [80h]
MOVZX reg32,reg16/mem16      MOVZX   EAX,DX
\end{verbatim}

\section{MOVUPS --- MOVe Unaligned Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MOVUPS xmmreg,xmmreg/mem128  MOVUPS  XMM3,OWORD_VAR[ECX*4]
MOVUPS xmmreg/mem128,xmmreg  MOVUPS  XMM3,XMM
\end{verbatim}

\section{MUL --- unsigned MULtiply}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MUL reg8/mem8                MUL     CH
MUL reg16/mem16              MUL     WORD [BX]
MUL reg32/mem32              MUL     EBP
\end{verbatim}

\section{MULPD --- MULtiply Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MULPD xmmreg,xmmreg/mem128   MULPD   XMM2,XMM7
\end{verbatim}

\section{MULPS --- MULtiply Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MULPS xmmreg,xmmreg/mem128   MULPS   XMM2,[EBX]
\end{verbatim}

\section{MULSD --- MULtiply Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MULSD xmmreg,xmmreg/mem64    MULSD   XMM2,[EBX]
\end{verbatim}

\section{MULSS --- MULtiply Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
MULSS xmmreg,xmmreg/mem32    MULSS   XMM2,[EBX]
\end{verbatim}

\section{NEG --- two's complement NEGation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
NEG reg8/mem8                NEG     CH
NEG reg16/mem16              NEG     WORD [BX]
NEG reg32/mem32              NEG     EBP
\end{verbatim}

\section{NOP --- No OPeration}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
NOP (no arguments)           NOP
\end{verbatim}

\section{NOT --- one's complement negation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
NOT reg8/mem8                NOT     CH
NOT reg16/mem16              NOT     WORD [BX]
NOT reg32/mem32              NOT     EBP
\end{verbatim}

\section{OR --- logical inclusive OR}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
OR reg,reg/mem               OR      AX,BX
OR mem,reg                   OR      [80h],DL
OR reg/mem,immed             OR      BYTE [GS:WORD_VAR],18
OR reg/mem,signed8           OR      ESI,-6
\end{verbatim}

\section{ORPD --- bitwise logical OR of Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ORPD xmmreg,xmmreg/mem128    ORPD    XMM2,[EBX]
\end{verbatim}

\section{ORPS --- bitwise logical OR of Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ORPS xmmreg,xmmreg/mem128    ORPS    XMM2,[EBX]
\end{verbatim}

\section{OUT --- OUTput to port}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
OUT unsigned8,accum          OUT     42h,AL
OUT DX,accum                 OUT     DX,EAX
\end{verbatim}

\section{OUTS / OUTSB / OUTSW / OUTSD --- OUTput String}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
OUTS DX,mem8/mem16/mem32     OUTS    DX,[MY_NAME]
OUTSB (no arguments)         OUTSB
OUTSW (no arguments)         OUTSW
OUTSD (no arguments)         OUTSD
\end{verbatim}

\section{PACKSSWB / PACKSSDW --- PACK with Sign Saturation}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PACKSSWB mmreg,mmreg/mem64    PACKSSWB MM5,[BP+DI+500h]
PACKSSWB xmmreg,xmmreg/mem128 PACKSSWB XMM4,XMM7
PACKSSDW mmreg,mmreg/mem64    PACKSSDW MM5,[BP+DI+500h]
PACKSSDW xmmreg,xmmreg/mem128 PACKSSDW XMM4,XMM7
\end{verbatim}

\section{PACKUSWB --- PACK with Unsigned Saturation}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PACKUSWB mmreg,mmreg/mem64    PACKUSWB MM5,[BP+DI+500h]
PACKUSWB xmmreg,xmmreg/mem128 PACKUSWB XMM4,XMM7
\end{verbatim}

\section{PADDB / PADDW / PADDD / PADDQ --- ADD Packed integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PADDB mmreg,mmreg/mem64      PADDB   MM6,MM1
PADDB xmmreg,xmmreg/mem128   PADDB   XMM,ES:[BX+DI-32]
PADDW mmreg,mmreg/mem64      PADDW   MM6,MM1
PADDW xmmreg,xmmreg/mem128   PADDW   XMM,ES:[BX+DI-32]
PADDD mmreg,mmreg/mem64      PADDD   MM6,MM1
PADDD xmmreg,xmmreg/mem128   PADDD   XMM,ES:[BX+DI-32]
PADDQ mmreg,mmreg/mem64      PADDQ   MM6,MM1
PADDQ xmmreg,xmmreg/mem128   PADDQ   XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PADDSB / PADDSW --- ADD Packed Signed integers with signed saturation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PADDSB mmreg,mmreg/mem64     PADDSB  MM6,MM1
PADDSB xmmreg,xmmreg/mem128  PADDSB  XMM,ES:[BX+DI-32]
PADDSW mmreg,mmreg/mem64     PADDSW  MM6,MM1
PADDSW xmmreg,xmmreg/mem128  PADDSW  XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PADDUSB / PADDUSW --- ADD Packed Unsigned integers with unsigned saturation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PADDUSB mmreg,mmreg/mem64    PADDUSB MM6,MM1
PADDUSB xmmreg,xmmreg/mem128 PADDUSB XMM,ES:[BX+DI-32]
PADDUSW mmreg,mmreg/mem64    PADDUSW MM6,MM1
PADDUSW xmmreg,xmmreg/mem128 PADDUSW XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PAND --- Logical AND}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PAND mmreg,mmreg/mem64       PAND    MM6,MM1
PAND xmmreg,xmmreg/mem128    PAND    XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PANDN --- Logical AND NOT}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PANDN mmreg,mmreg/mem64      PANDN   MM6,MM1
PANDN xmmreg,xmmreg/mem128   PANDN   XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PAUSE --- spin loop hint}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PAUSE (no argumenta)         PAUSE
\end{verbatim}

\section{PAVGB / PAVGW --- AVeraGe Packed integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PAVGB mmreg,mmreg/mem64      PAVGB   MM6,MM1
PAVGB xmmreg,xmmreg/mem128   PAVGB   XMM,ES:[BX+DI-32]
PAVGW mmreg,mmreg/mem64      PAVGW   MM6,MM1
PAVGW xmmreg,xmmreg/mem128   PAVGW   XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PAVGUSB --- AVeraGe of unsigned Packed 8-bit values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PAVGUSB mmreg,mmreg/mem64    PAVGUSB MM6,MM1
PAVGUSB xmmreg,xmmreg/mem128 PAVGUSB XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PCMPEQB / PCMPEQW / PCMPEQD --- CoMPare Packed data for EQual}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PCMPEQB mmreg,mmreg/mem64    PCMPEQB MM6,MM1
PCMPEQB xmmreg,xmmreg/mem128 PCMPEQB XMM,ES:[BX+DI-32]
PCMPEQW mmreg,mmreg/mem64    PCMPEQW MM6,MM1
PCMPEQW xmmreg,xmmreg/mem128 PCMPEQW XMM,ES:[BX+DI-32]
PCMPEQD mmreg,mmreg/mem64    PCMPEQD MM6,MM1
PCMPEQD xmmreg,xmmreg/mem128 PCMPEQD XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PCMPGTB / PCMPGTW / PCMPGTD --- CoMPare Packed signed integers for Greater Than}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PCMPGTB mmreg,mmreg/mem64    PCMPGTB MM6,MM1
PCMPGTB xmmreg,xmmreg/mem128 PCMPGTB XMM,ES:[BX+DI-32]
PCMPGTW mmreg,mmreg/mem64    PCMPGTW MM6,MM1
PCMPGTW xmmreg,xmmreg/mem128 PCMPGTW XMM,ES:[BX+DI-32]
PCMPGTD mmreg,mmreg/mem64    PCMPGTD MM6,MM1
PCMPGTD xmmreg,xmmreg/mem128 PCMPGTD XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PEXTRW --- EXTRact Word}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PEXTRW reg32,mmreg,unsigned8  PEXTRW  ECX,MM,3
PEXTRW reg32,xmmreg,unsigned8 PEXTRW  ECX,XMM0,5
\end{verbatim}

\subsection{Notes}
\popasm\ checks whether or not the immediate argument is valid.
If the second argument is a MMX register, the third argument must
be in 0--3 interval. Likewise, if the second argument is a
XMM register, the third argument should be in 0--7 interval.

\section{PF2ID --- convert Packed Floating-point operand to packed 32-bit Integer}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PF2ID mmreg,mmreg/mem64      PF2ID   MM6,MM1
\end{verbatim}

\section{PF2IW --- convert Packed Floating-point operand to Integer Word with sign-extend}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PF2IW mmreg,mmreg/mem64      PF2IW   MM6,MM1
\end{verbatim}

\section{PFACC --- Packed Floating-point ACCumulate}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFACC mmreg,mmreg/mem64      PFACC   MM6,MM1
\end{verbatim}

\section{PFADD --- Packed Floating-point ADDition}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFADD mmreg,mmreg/mem64      PFADD   MM6,MM1
\end{verbatim}

\section{PFCMPEQ --- Packed Floating-point CoMParison, EQual}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFCMPEQ mmreg,mmreg/mem64    PFCMPEQ MM6,MM1
\end{verbatim}

\section{PFCMPGE --- Packed Floating-point CoMParison, Greater or Equal}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFCMPGE mmreg,mmreg/mem64    PFCMPGE MM6,MM1
\end{verbatim}

\section{PFCMPGT --- Packed Floating-point CoMParison, Greater Than}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFCMPGT mmreg,mmreg/mem64    PFCMPGT MM6,MM1
\end{verbatim}

\section{PFMAX --- Packed Floating-point MAXimum}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFMAX mmreg,mmreg/mem64      PFMAX   MM6,MM1
\end{verbatim}

\section{PFMIN --- Packed Floating-point MINimum}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFMIN mmreg,mmreg/mem64      PFMIN   MM6,MM1
\end{verbatim}

\section{PFMUL --- Packed Floating-point MULtiplication}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFMUL mmreg,mmreg/mem64      PFMUL   MM6,MM1
\end{verbatim}

\section{PFNACC --- Packed Floating-point Negative ACCumulate}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFACC mmreg,mmreg/mem64      PFACC   MM6,MM1
\end{verbatim}

\section{PFPNACC --- Packed Floating-point mixed Positive-Negative ACCumulate}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFNACC mmreg,mmreg/mem64     PFNACC  MM6,MM1
\end{verbatim}

\section{PFRCP --- Packed Floating-point ReCiProcal approximation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFRCP mmreg,mmreg/mem64      PFRCP   MM6,MM1
\end{verbatim}

\section{PFRCPIT1 --- Packed Floating-point ReCiProcal approximation, firat ITeration step}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFRCPIT1 mmreg,mmreg/mem64   PFRCPIT1 MM6,MM1
\end{verbatim}

\section{PFRCPIT2 --- Packed Floating-point ReCiProcal approximation, second ITeration step}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFRCPIT2 mmreg,mmreg/mem64   PFRCPIT2 MM6,[BP+DI+32]
\end{verbatim}

\section{PFRSQIT1 --- Packed Floating-point Reciprocal SQuare root, firat ITeration step}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFRSQIT1 mmreg,mmreg/mem64   PFRSQIT1 MM6,MM1
\end{verbatim}

\section{PFRSQRT --- Packed Floating-point Reciprocal SQuare RooT approximation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFRSQRT mmreg,mmreg/mem64    PFRSQRT MM3,MM
\end{verbatim}

\section{PFSUB --- Packed Floating-point SUBtraction}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFSUB mmreg,mmreg/mem64      PFSUB   MM7,MM1
\end{verbatim}

\section{PFSUBR --- Packed Floating-point Reverse SUBtraction}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PFSUBR mmreg,mmreg/mem64     PFSUBR  MM7,MM1
\end{verbatim}

\section{PI2FD --- Packed 32-bit Integer to Floating-point conversion}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PI2FD mmreg,mmreg/mem64      PI2FD   MM7,MM1
\end{verbatim}

\section{PI2FW --- Packed 16-bit Integer to Floating-point conversion}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PI2FW mmreg,mmreg/mem64      PI2FW   MM6,MM1
\end{verbatim}

\section{PINSRW --- INSeRt Word}
\begin{verbatim}
Valid Syntaxes                      Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PINSRW mmreg,reg32/mem16,unsigned8  PINSRW  MM,ECX,3
PINSRW xmmreg,reg32/mem16,unsigned8 PINSRW  XMM0,EDX,5
\end{verbatim}

\subsection{Notes}
\popasm\ checks whether or not the immediate argument is valid.
If the first argument is a MMX register, the third argument must
be in 0--3 interval. Likewise, if the first argument is a
XMM register, the third argument should be in 0--7 interval.

\section{PMADDWD --- Multiply and ADD Packed integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMADDWD mmreg,mmreg/mem64    PMADDWD MM0,QWORD [VAR]
PMADDWW xmmreg,xmmreg/mem128 PMADDWD XMM3,XMM1
\end{verbatim}

\section{PMAXSW --- MAXimum of Packed Signed Word integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMAXSW mmreg,mmreg/mem64     PMAXSW  MM0,QWORD [VAR]
PMAXSW xmmreg,xmmreg/mem128  PMAXSW  XMM3,XMM1
\end{verbatim}

\section{PMAXUB --- MAXimum of Packed Unsigned Byte integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMAXUB mmreg,mmreg/mem64     PMAXUB  MM0,QWORD [VAR]
PMAXUB xmmreg,xmmreg/mem128  PMAXUB  XMM3,XMM1
\end{verbatim}

\section{PMINSW --- MINimum of Packed Signed Word integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMINSW mmreg,mmreg/mem64     PMINSW  MM0,QWORD [VAR]
PMINSW xmmreg,xmmreg/mem128  PMINSW  XMM3,XMM1
\end{verbatim}

\section{PMINUB --- MINimum of Packed Unsigned Byte integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMINUB mmreg,mmreg/mem64     PMINUB  MM0,QWORD [VAR]
PMINUB xmmreg,xmmreg/mem128  PMINUB  XMM3,XMM1
\end{verbatim}

\section{PMOVMSKB --- MOV Byte MaSK}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMOVMSKB reg32,mmreg         PMOVMSKB EDX,MM6
PMOVMSKB reg32,xmmreg        PMOVMSKB EBP,XMM4
\end{verbatim}

\section{PMULHRW --- MULtiply signed Packed 16-bit values with Rounding and store the High 16 bits}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMULHRW mmreg,mmreg/mem64    PMULHRW MM7,MM1
\end{verbatim}

\section{PMULHUW --- MULtiply Packed Unsigned integers and store High result}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMULHUW mmreg,mmreg/mem64    PMULHUW MM4,[VAR]
PMULHUW xmmreg,xmmreg/mem64  PMULHUW XMM5,XMM1
\end{verbatim}

\section{PMULHW --- MULtiply Packed signed integers and store High result}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMULHW mmreg,mmreg/mem64     PMULHW  MM4,[VAR]
PMULHW xmmreg,xmmreg/mem64   PMULHW  XMM5,XMM1
\end{verbatim}

\section{PMULLW --- MULtiply Packed signed integers and store Low result}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMULLW mmreg,mmreg/mem64     PMULLW  MM4,[VAR]
PMULLW xmmreg,xmmreg/mem64   PMULLW  XMM5,XMM1
\end{verbatim}

\section{PMULUDQ --- MULtiply Packed Unsigned Doubleword integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PMULUDQ mmreg,mmreg/mem64    PMULUDQ MM4,[VAR]
PMULUDQ xmmreg,xmmreg/mem64  PMULUDQ XMM5,XMM1
\end{verbatim}

\section{POP --- POP a value from the stack}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
POP reg16/reg32/mem16/mem32  POP     AX
POP segreg                   POP     GS
\end{verbatim}

\subsection{Notes}
It is not possible to POP CS.

\section{POPA / POPAD --- POP All general-purpose registers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
POPA (no arguments)          POPA
POPAD (no arguments)         POPAD
\end{verbatim}

\section{POPF / POPFD --- POP stack into eFlags register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
POPF (no arguments)          POPF
POPFD (no arguments)         POPFD
\end{verbatim}

\section{POR --- Logical OR}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
POR mmreg,mmreg/mem64        POR     MM6,MM1
POR xmmreg,xmmreg/mem128     POR     XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PREFETCHh --- PREFETCH data into caches}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PREFETCH  mem8               PREFETCH  [EBX+ECX]
PREFETCH0 mem8               PREFETCH0 [BX+12]
PREFETCH1 mem8               PREFETCH1 [CLIENTS]
PREFETCH2 mem8               PREFETCH2 ES:[BP-64]
PREFETCHNTA mem8             PREFETCHNTA [EAX]
PREFETCHW mem8               PREFETCHW [EBX+ECX]
\end{verbatim}

\subsection{Notes}
If the argument size is not specified \popasm\ assumes
it is a byte variable, so both statements below are ok:

\begin{verbatim}
                PREFETCH0 BYTE [BX]
                PREFETCH0 [BX]
\end{verbatim}

\section{PSADDBW --- compute Sum of Absolute Differences}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSADBW mmreg,mmreg/mem64     PSADBW  MM6,MM1
PSADBW xmmreg,xmmreg/mem128  PSADBW  XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PSHUFD --- SHUFfle Packed Doublewords}
\begin{verbatim}
Valid Syntaxes                        Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSHUFD xmmreg,xmmreg/mem128,unsigned8 PSHUFD  XMM,XMM1,00_01_10_11B
\end{verbatim}

\section{PSHUFHW --- SHUFfle Packed High Words}
\begin{verbatim}
Valid Syntaxes                         Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSHUFHW xmmreg,xmmreg/mem128,unsigned8 PSHUFHW XMM,XMM1,00_01_10_11B
\end{verbatim}

\section{PSHUFLW --- SHUFfle Packed Low Words}
\begin{verbatim}
Valid Syntaxes                         Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSHUFLW xmmreg,xmmreg/mem128,unsigned8 PSHUFLW XMM,XMM1,00_01_10_11B
\end{verbatim}

\section{PSHUFW --- SHUFfle Packed Words}
\begin{verbatim}
Valid Syntaxes                     Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSHUFW mmreg,mmreg/mem64,unsigned8 PSHUFW  MM,MM1,00_01_10_11B
\end{verbatim}

\section{PSLLDQ --- Shift Double Quadword Left Logical}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSLLDQ xmmreg,unsigned8      PSLLDQ  XMM,00_01_10_11B
\end{verbatim}

\section{PSLLW / PSLLD / PSLLQ --- Shift Packed Data Left Logical}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSLLW mmreg,mmreg/mem64      PSLLW   MM5,[AMOUNTS]
PSLLW xmmreg,xmmreg/mem128   PSLLW   XMM5,XMM2
PSLLW mmreg,mmreg/mem64      PSLLW   MM5,3
PSLLW xmmreg,xmmreg/mem128   PSLLW   XMM3,4
PSLLD mmreg,mmreg/mem64      PSLLD   MM5,[AMOUNTS]
PSLLD xmmreg,xmmreg/mem128   PSLLD   XMM5,XMM2
PSLLD mmreg,mmreg/mem64      PSLLD   MM5,3
PSLLD xmmreg,xmmreg/mem128   PSLLD   XMM3,4
PSLLQ mmreg,mmreg/mem64      PSLLQ   MM5,[AMOUNTS]
PSLLQ xmmreg,xmmreg/mem128   PSLLQ   XMM5,XMM2
PSLLQ mmreg,mmreg/mem64      PSLLQ   MM5,3
PSLLQ xmmreg,xmmreg/mem128   PSLLQ   XMM3,4
\end{verbatim}

\subsection{Notes}
When those instructions are used with immediate arguments, \popasm\ 
checks if they are in 0--15, 0--31 and 0--63 intervals for PSLLW,
PSLLD and PSLLQ, respectively.

\section{PSRAW / PSRAD --- Shift Packed Data Left Logical}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSRAW mmreg,mmreg/mem64      PSRAW   MM5,[AMOUNTS]
PSRAW xmmreg,xmmreg/mem128   PSRAW   XMM5,XMM2
PSRAW mmreg,mmreg/mem64      PSRAW   MM5,3
PSRAW xmmreg,xmmreg/mem128   PSRAW   XMM3,4
PSRAD mmreg,mmreg/mem64      PSRAD   MM5,[AMOUNTS]
PSRAD xmmreg,xmmreg/mem128   PSRAD   XMM5,XMM2
PSRAD mmreg,mmreg/mem64      PSRAD   MM5,3
PSRAD xmmreg,xmmreg/mem128   PSRAD   XMM3,4
\end{verbatim}

\subsection{Notes}
When those instructions are used with immediate arguments, \popasm\ 
checks if they are in 0--15 and 0--31 intervals for PSRAW and PSRAD,
respectively.

\section{PSRLDQ --- Shift Double Quadword Right Logical}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSRLDQ xmmreg,unsigned8      PSRLDQ  XMM5,1
\end{verbatim}

\subsection{Notes}
\popasm\ checks if the second argument is greater than 15. If it is
an error message is issued.

\section{PSRLW / PSRLD / PSRLQ --- Shift Packed Data Right Logical}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSRLW mmreg,mmreg/mem64      PSRLW   MM5,[AMOUNTS]
PSRLW xmmreg,xmmreg/mem128   PSRLW   XMM5,XMM2
PSRLW mmreg,mmreg/mem64      PSRLW   MM5,3
PSRLW xmmreg,xmmreg/mem128   PSRLW   XMM3,4
PSRLD mmreg,mmreg/mem64      PSRLD   MM5,[AMOUNTS]
PSRLD xmmreg,xmmreg/mem128   PSRLD   XMM5,XMM2
PSRLD mmreg,mmreg/mem64      PSRLD   MM5,3
PSRLD xmmreg,xmmreg/mem128   PSRLD   XMM3,4
PSRLQ mmreg,mmreg/mem64      PSRLQ   MM5,[AMOUNTS]
PSRLQ xmmreg,xmmreg/mem128   PSRLQ   XMM5,XMM2
PSRLQ mmreg,mmreg/mem64      PSRLQ   MM5,3
PSRLQ xmmreg,xmmreg/mem128   PSRLQ   XMM3,4
\end{verbatim}

\subsection{Notes}
When those instructions are used with immediate arguments, \popasm\ 
checks if they are in 0--15, 0--31 and 0--63 intervals for PSRLW,
PSRLD and PSRLQ, respectively.

\section{PSUBB / PSUBW / PSUBD / PSUBQ --- ADD Packed integers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSUBB mmreg,mmreg/mem64      PSUBB   MM6,MM1
PSUBB xmmreg,xmmreg/mem128   PSUBB   XMM,ES:[BX+DI-32]
PSUBW mmreg,mmreg/mem64      PSUBW   MM6,MM1
PSUBW xmmreg,xmmreg/mem128   PSUBW   XMM,ES:[BX+DI-32]
PSUBD mmreg,mmreg/mem64      PSUBD   MM6,MM1
PSUBD xmmreg,xmmreg/mem128   PSUBD   XMM,ES:[BX+DI-32]
PSUBQ mmreg,mmreg/mem64      PSUBQ   MM6,MM1
PSUBQ xmmreg,xmmreg/mem128   PSUBQ   XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PSUBSB / PSUBSW --- SUBtract Packed Signed integers with signed saturation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSUBSB mmreg,mmreg/mem64     PSUBSB  MM6,MM1
PSUBSB xmmreg,xmmreg/mem128  PSUBSB  XMM,ES:[BX+DI-32]
PSUBSW mmreg,mmreg/mem64     PSUBSW  MM6,MM1
PSUBSW xmmreg,xmmreg/mem128  PSUBSW  XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PSUBUSB / PSUBUSW --- ADD Packed Unsigned integers with unsigned saturation}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSUBUSB mmreg,mmreg/mem64    PSUBUSB MM6,MM1
PSUBUSB xmmreg,xmmreg/mem128 PSUBUSB XMM,ES:[BX+DI-32]
PSUBUSW mmreg,mmreg/mem64    PSUBUSW MM6,MM1
PSUBUSW xmmreg,xmmreg/mem128 PSUBUSW XMM,ES:[BX+DI-32]
\end{verbatim}

\section{PSWAPD --- Packed SWAP Doubleword}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PSWAPD mmreg,mmreg/mem64     PSWAPD  MM6,MM1
\end{verbatim}

\section{PUNPCKHBW / PUNPCKHWD / PUNPCKHDQ / PUNPCKHQDQ --- UNPaCK High data}
\begin{verbatim}
Valid Syntaxes                  Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PUNPCKHBW  mmreg,mmreg/mem64    PUNPCKHBW  MM2,[SAMPLES]
PUNPCKHBW  xmmreg,xmmreg/mem128 PUNPCKHBW  XMM0,XMM6
PUNPCKHWD  mmreg,mmreg/mem64    PUNPCKHWD  MM2,[SAMPLES]
PUNPCKHWD  xmmreg,xmmreg/mem128 PUNPCKHWD  XMM0,XMM6
PUNPCKHDQ  mmreg,mmreg/mem64    PUNPCKHDQ  MM2,[SAMPLES]
PUNPCKHDQ  xmmreg,xmmreg/mem128 PUNPCKHDQ  XMM0,XMM6
PUNPCKHQDQ xmmreg,xmmreg/mem128 PUNPCKHQDQ XMM0,XMM6
\end{verbatim}

\section{PUNPCKLBW / PUNPCKLWD / PUNPCKLDQ / PUNPCKLQDQ --- UNPaCK Low data}
\begin{verbatim}
Valid Syntaxes                  Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PUNPCKLBW  mmreg,mmreg/mem64    PUNPCKLBW  MM2,[SAMPLES]
PUNPCKLBW  xmmreg,xmmreg/mem128 PUNPCKLBW  XMM0,XMM6
PUNPCKLWD  mmreg,mmreg/mem64    PUNPCKLWD  MM2,[SAMPLES]
PUNPCKLWD  xmmreg,xmmreg/mem128 PUNPCKLWD  XMM0,XMM6
PUNPCKLDQ  mmreg,mmreg/mem64    PUNPCKLDQ  MM2,[SAMPLES]
PUNPCKLDQ  xmmreg,xmmreg/mem128 PUNPCKLDQ  XMM0,XMM6
PUNPCKLQDQ xmmreg,xmmreg/mem128 PUNPCKLQDQ XMM0,XMM6
\end{verbatim}

\section{PUSH --- PUSH word or doubleword onto the stack}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PUSH reg16/reg32/mem16/mem32 PUSH EBP
PUSH signed8                 PUSH -5
PUSH immed16/immed32         PUSH OFFSET BUFFER
PUSH segreg                  PUSH DS
\end{verbatim}

\subsection{Notes}
The short form for this instruction is used whenever possible.
However, the longer form can be forced by specifying the
argument size. Likewise, a 32-bits PUSH can be issued in
16-bits mode and vice-versa by means of size specifiers.
Finally, immediate values larger that 0FFFFh must be preceeded
by a DWORD size specifier when in 16-bits mode. All of this
is shown in the mext example:

\begin{verbatim}
                PUSH    5                       ; 8-bits
                PUSH    BYTE 5                  ; same as above

                BITS    16

                PUSH    1234h                   ; 16-bits
                PUSH    DWORD 1234h             ; 32-bits
                PUSH    10000h                  ; Error!
                PUSH    DWORD 10000h            ; Ok, 32-bits

                BITS    32

                PUSH    1234h                   ; 32-bits
                PUSH    WORD 1234h              ; 16-bits
\end{verbatim}

\section{PUSHA / PUSHAD --- PUSH All general-purpose registers}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PUSHA (no arguments)         PUSHA
PUSHAD (no arguments)        PUSHAD
\end{verbatim}

\section{PUSHF / PUSHFD --- PUSH stack into eFlags register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PUSHF (no arguments)         PUSHF
PUSHFD (no arguments)        PUSHFD
\end{verbatim}

\section{PXOR --- Logical XOR}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
PXOR mmreg,mmreg/mem64       PXOR    MM6,MM1
PXOR xmmreg,xmmreg/mem128    PXOR    XMM,ES:[BX+DI-32]
\end{verbatim}

\section{RCL / RCR / ROL / ROR --- Rotate}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RCL reg8/mem8,unsigned8      RCL     AL,1
RCL reg16/mem16,unsigned8    RCL     BX,3
RCL reg32/mem32,unsigned8    RCL     EDX,3
RCL reg8/mem8,CL             RCL     AL,CL
RCL reg16/mem16,CL           RCL     BX,CL
RCL reg32/mem32,CL           RCL     EDX,CL
RCR reg8/mem8,unsigned8      RCR     AL,1
RCR reg16/mem16,unsigned8    RCR     BX,3
RCR reg32/mem32,unsigned8    RCR     EDX,3
RCR reg8/mem8,CL             RCR     AL,CL
RCR reg16/mem16,CL           RCR     BX,CL
RCR reg32/mem32,CL           RCR     EDX,CL
ROL reg8/mem8,unsigned8      ROL     AL,1
ROL reg16/mem16,unsigned8    ROL     BX,3
ROL reg32/mem32,unsigned8    ROL     EDX,3
ROL reg8/mem8,CL             ROL     AL,CL
ROL reg16/mem16,CL           ROL     BX,CL
ROL reg32/mem32,CL           ROL     EDX,CL
ROR reg8/mem8,unsigned8      ROR     AL,1
ROR reg16/mem16,unsigned8    ROR     BX,3
ROR reg32/mem32,unsigned8    ROR     EDX,3
ROR reg8/mem8,CL             ROR     AL,CL
ROR reg16/mem16,CL           ROR     BX,CL
ROR reg32/mem32,CL           ROR     EDX,CL
\end{verbatim}

\subsection{Notes}
When the immediate argument is 1, there is an optimized encoding
for the instruction, which is used by default. Such behavior may
be overriden by a size specifier. For example:

\begin{verbatim}
                RCL     AX,1
                RCL     AX,BYTE 1
\end{verbatim}

Also, the value of the argument is checked against the size of
the first argument. If it is greater than or equal, an error
message is issued.

\section{RCPPS --- compute ReCiProcals of Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RCPPS xmmreg,xmmreg/mem128   RCPPS   XMM3,[ES:VALUES]
\end{verbatim}

\section{RCPSS --- compute ReCiProcals of Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RCPSS xmmreg,xmmreg/mem32    RCPSS   XMM3,[DISTANCE]
\end{verbatim}

\section{RDMSR --- ReaD from Model Specific Register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RDMSR (no arguments)         RDMSR
\end{verbatim}

\section{RDPMC --- ReaD from Performance Monitoring Counters}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RDPMC (no arguments)         RDPMC
\end{verbatim}

\section{RDTSC --- ReaD from Time Stamp Counter}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RDTSC (no arguments)         RDTSC
\end{verbatim}

\section{REP / REPE / REPZ / REPNE / REPNZ --- REPeat string operation prefix}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
REP (no arguments)           REP
REP instruction              REP     STOSB
REPE (no arguments)          REPE
REPE instruction             REPE    CMPSB
REPZ (no arguments)          REPZ
REPZ instruction             REPZ    SCASB
REPNE (no arguments)         REPNE
REPNE instruction            REPNE   SCASD
REPNZ (no arguments)         REPNZ
REPNZ instruction            REPNZ   SCASW
\end{verbatim}

\section{RET / RETN / RETF --- RETurn from procedure}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RET (no arguments)           RET
RET unsigned16               RET     16
RETN (no arguments)          RETN
RETN unsigned16              RETN    256
RETF (no arguments)          RETF
RETF unsigned16              RETF    4
\end{verbatim}

\subsection{Notes}
\popasm\ replaces RET instructions for either RETN or RETF depending on local
context (i.e. the procedure being exitted is NEAR or FAR). If the instruction
is used outside a procedure, its NEAR form is used. The developer may also use
the explicit forms RETN inside far procedures and RETF inside near procedures
as necessary.

\section{RSM --- Resume from System Management mode}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RSM (no arguments)           RSM
\end{verbatim}

\section{RSQRTPS --- compute Reciprocals of SQuare RooTs of Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RSQRTPS xmmreg,xmmreg/mem128 RSQRTPS XMM3,[ES:VALUES]
\end{verbatim}

\section{RSQRTSS --- compute ReCiProcals of SQuare RooTs of Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
RSQRTSS xmmreg,xmmreg/mem32  RSQRTSS XMM3,[DISTANCES]
\end{verbatim}

\section{SAHF --- Store AH into Flags}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SAHF (no arguments)          SAHF
\end{verbatim}

\section{SHL / SHR / SAL / SAR --- Shift}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SHL reg8/mem8,unsigned8      SHL     AL,1
SHL reg16/mem16,unsigned8    SHL     BX,3
SHL reg32/mem32,unsigned8    SHL     EDX,3
SHL reg8/mem8,CL             SHL     AL,CL
SHL reg16/mem16,CL           SHL     BX,CL
SHL reg32/mem32,CL           SHL     EDX,CL
SHR reg8/mem8,unsigned8      SHR     AL,1
SHR reg16/mem16,unsigned8    SHR     BX,3
SHR reg32/mem32,unsigned8    SHR     EDX,3
SHR reg8/mem8,CL             SHR     AL,CL
SHR reg16/mem16,CL           SHR     BX,CL
SHR reg32/mem32,CL           SHR     EDX,CL
SAL reg8/mem8,unsigned8      SAL     AL,1
SAL reg16/mem16,unsigned8    SAL     BX,3
SAL reg32/mem32,unsigned8    SAL     EDX,3
SAL reg8/mem8,CL             SAL     AL,CL
SAL reg16/mem16,CL           SAL     BX,CL
SAL reg32/mem32,CL           SAL     EDX,CL
SAR reg8/mem8,unsigned8      SAR     AL,1
SAR reg16/mem16,unsigned8    SAR     BX,3
SAR reg32/mem32,unsigned8    SAR     EDX,3
SAR reg8/mem8,CL             SAR     AL,CL
SAR reg16/mem16,CL           SAR     BX,CL
SAR reg32/mem32,CL           SAR     EDX,CL
\end{verbatim}

\subsection{Notes}
When the immediate argument is 1, there is an optimized encoding
for the instruction, which is used by default. Such behavior may
be overriden by a size specifier. For example:

\begin{verbatim}
                SHL     AX,1
                SHL     AX,BYTE 1
\end{verbatim}

Also, the value of the argument is checked against the size of
the first argument. If it is greater than or equal, an error
message is issued.

\section{SBB --- integer SuBtraction with Borrow}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SBB reg,reg/mem              SBB     CL,DH
SBB mem,reg                  SBB     [80h],EDX
SBB reg/mem,immed            SBB     [VAR],18
SBB reg/mem,signed8          SBB     EAX,-6
\end{verbatim}

\section{SCAS / SCASB / SCASW / SCASD --- SCAn String}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SCAS mem8/mem16/mem32        SCAS    BYTE ES:[ESI]
SCASB (no arguments)         SCASB
SCASW (no arguments)         SCASW
SCASD (no arguments)         SCASD
\end{verbatim}

\section{SETcc --- SET byte on condition}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SETCC reg8/mem8              SETCC   DH
\end{verbatim}

\subsection{Notes}
SETcc refers to a set of instructions that check different conditions.
Suported variants are:

\begin{itemize}
\item SETA --- SET if Above
\item SETAE --- SET if Above or Equal
\item SETB --- SET if Below
\item SETBE --- SET if Below or Equal
\item SETC --- SET if Carry
\item SETE --- SET if Equal
\item SETG --- SET if Greater
\item SETGE --- SET if Greater or Equal
\item SETL --- SET if Less
\item SETLE --- SET if Less or Equal
\item SETNA --- SET if Not Above
\item SETNAE --- SET if Not Above or Equal
\item SETNB --- SET if Not Below
\item SETNBE --- SET if Not Below or Equal
\item SETNC --- SET if Not Carry
\item SETNE --- SET if Not Equal
\item SETNG --- SET if Not Greater
\item SETNGE --- SET if Not Greater or Equal
\item SETNL --- SET if Not Less
\item SETNLE --- SET if Not Less or Equal
\item SETNO --- SET if Not Overflow
\item SETNP --- SET if Not Parity
\item SETNS --- SET if Not Sign
\item SETNZ --- SET if Not Zero
\end{itemize}

\section{SFENCE --- Store FENCE}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SFENCE (no arguments)        SFENCE
\end{verbatim}

\section{SGDT --- Store Global Descriptor Table register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SGDT mem48                   SGDT    [INITIAL_GDTR]
\end{verbatim}

\section{SIDT --- Store Interrupt Descriptor Table register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SIDT mem48                   SGDT    [INITIAL_IDTR]
\end{verbatim}

\section{SHLD / SHRD --- Double-precision SHift}
\begin{verbatim}
Valid Syntaxes                   Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SHLD reg16/mem16,reg16,unsigned8 SHLD    AX,BX,1
SHLD reg16/mem32,reg32,unsigned8 SHLD    EAX,EBX,1
SHLD reg16/mem16,reg16,CL        SHLD    AX,BX,CL
SHLD reg16/mem32,reg32,CL        SHLD    EAX,EBX,CL
SHRD reg16/mem16,reg16,unsigned8 SHRD    AX,BX,1
SHRD reg16/mem32,reg32,unsigned8 SHRD    EAX,EBX,1
SHRD reg16/mem16,reg16,CL        SHRD    AX,BX,CL
SHRD reg16/mem32,reg32,CL        SHRD    EAX,EBX,CL
\end{verbatim}

\subsection{Notes}
If the last argument is an immediate value, \popasm\ checks whether
it is less than the other arguments' sizes. If not, an error message
is issued.

\section{SHUFPD --- SHUFfle Packed Doubleword floating-point values}
\begin{verbatim}
Valid Syntaxes                        Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SHUFPD xmmreg,xmmreg/mem128,unsigned8 SHUFPD  XMM2,XMM6,1
\end{verbatim}

\subsection{Notes}
\popasm\ checks whether the last argument is in 0--3 interval. If it
is not an error message is displayed.

\section{SHUFPS --- SHUFfle Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes                        Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SHUFPS xmmreg,xmmreg/mem128,unsigned8 SHUFPD  XMM2,XMM6,10_01_11_00B
\end{verbatim}

\section{SLDT --- Store Local Descriptor Table register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SLDT reg16/mem16/reg32/mem32 SLDT    DX
\end{verbatim}

\section{SMSW --- Store Machine Status Word}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SMSW reg16/mem16/reg32       SMSW    DX
\end{verbatim}

\section{SQRTPD --- compute SQuare RooTs of Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SQRTPD xmmreg,xmmreg/mem128  SQRTPD  XMM2,XMM6
\end{verbatim}

\section{SQRTPS --- compute SQuare RooTs of Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SQRTPS xmmreg,xmmreg/mem128  SQRTPS  XMM2,XMM6
\end{verbatim}

\section{SQRTSD --- compute SQuare RooTs of Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SQRTSD xmmreg,xmmreg/mem64   SQRTSD  XMM2,XMM6
\end{verbatim}

\section{SQRTSS --- compute SQuare RooTs of Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SQRTSS xmmreg,xmmreg/mem32   SQRTSS  XMM2,XMM6
\end{verbatim}

\section{STC --- SeT Carry flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
STC (no arguments)           STC
\end{verbatim}

\section{STD --- SeT Direction flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
STD (no arguments)           STD
\end{verbatim}

\section{STI --- SeT Interrupt flag}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
STI (no arguments)           STI
\end{verbatim}

\section{STMXCSR --- STore MXCSR state}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
STMXCSR (no arguments)       STMXCSR
\end{verbatim}

\section{STOS / STOSB / STOSW / STOSD --- STOre String}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
STOS mem8/mem16/mem32        STOS    BYTE ES:[ESI]
STOSB (no arguments)         STOSB
STOSW (no arguments)         STOSW
STOSD (no arguments)         STOSD
\end{verbatim}

\section{STR --- Store Task Register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
STR reg16/mem16              STR     AX
\end{verbatim}

\section{SUB --- SUBtract}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SUB reg,reg/mem              SUB     CL,DH
SUB mem,reg                  SUB     [80h],EDX
SUB reg/mem,immed            SUB     [VAR],18
SUB reg/mem,signed8          SUB     EAX,-6
\end{verbatim}

\section{SUBPD --- SUBtract Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SUBPD xmmreg,xmmreg/mem128   SUBPD   XMM,XMM1
\end{verbatim}

\section{SUBPS --- SUBtract Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SUBPS xmmreg,xmmreg/mem128   SUBPS   XMM5,TABLE[ESI]
\end{verbatim}

\section{SUBSD --- SUBtract Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SUBSD xmmreg,xmmreg/mem64    SUBSD   XMM5,[EDI+ARRAY]
\end{verbatim}

\section{SUBSS --- SUBtract Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SUBSS xmmreg,xmmreg/mem32    SUBSS   XMM3,ES:[BX]
\end{verbatim}

\section{SYSENTER --- fast SYStem call}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SYSENTER (no arguments)      SYSENTER
\end{verbatim}

\section{SYSEXIT --- fast return from fast SYStem call}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
SYSEXIT (no arguments)       SYSEXIT
\end{verbatim}

\section{TEST --- logical compare}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
TEST reg,reg/mem             TEST    AX,BX
TEST reg/mem,reg             TEST    [80h],DL
TEST reg/mem,immed           TEST    BYTE [GS:WORD_VAR],18
TEST reg/mem,signed8         TEST    ESI,-6
\end{verbatim}

\subsection{Notes}
Conversely to what has been stated above, this instruction has no
suport for the ``reg,mem'' argument combination. However, because
the order of the arguments does not affect the result, \popasm\ 
inverts that argument combination so that the instruction can be
assembled correctly.

\section{UCOMISD --- Unordered COMpare Scalar Double-precision floating-point values and set eflags}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UCOMISD xmmreg,xmmreg/mem64  UCOMISD XMM5,[EDI+ARRAY]
\end{verbatim}

\section{UCOMISS --- Unordered COMpare Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UCOMISS xmmreg,xmmreg/mem32  UCOMISS XMM3,ES:[BX]
\end{verbatim}

\section{UD2 --- UnDefined instruction}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UD2 (no arguments)           UD2
\end{verbatim}

\section{UNPCKHPD --- UNPaCK and interleave High Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UNPCKHPD xmmreg,xmmreg/mem128 UNPCKHPD XMM3,ES:[BX]
\end{verbatim}

\section{UNPCKHPS --- UNPaCK and interleave High Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UNPCKHPS xmmreg,xmmreg/mem128 UNPCKHPS XMM3,XMM1
\end{verbatim}

\section{UNPCKLPD --- UNPaCK and interleave Low Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UNPCKLPD xmmreg,xmmreg/mem128 UNPCKLPD XMM3,ES:[BX]
\end{verbatim}

\section{UNPCKLPS --- UNPaCK and interleave Low Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes                Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
UNPCKLPS xmmreg,xmmreg/mem128 UNPCKLPS XMM3,XMM1
\end{verbatim}

\section{VERR / VERW --- VERify a segment for Reading / Writing}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
VERR reg16/mem16             VERR    AX
VERW reg16/mem16             VERR    CX
\end{verbatim}

\section{WAIT --- WAIT}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
WAIT (no arguments)          WAIT
\end{verbatim}

\section{WBINVD --- Write Back and INValiDate cache}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
WBINVD (no arguments)        WBINVD
\end{verbatim}

\section{WRMSR --- WRite to Model Specific Register}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
WRMSR (no arguments)         WRMSR
\end{verbatim}

\section{XADD --- eXchange and ADD}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
XADD reg8/mem8,reg8          XADD    AL,BL
XADD reg16/mem16,reg16       XADD    AX,BX
XADD reg32/mem32,reg32       XADD    EAX,EBX
\end{verbatim}

\section{XCHG --- eXCHanGe}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
XCHG reg8/mem8,reg8          XCHG    AL,BL
XCHG reg8,reg8/mem8          XCHG    AL,[BX]
XCHG reg16/mem16,reg16       XCHG    AX,BX
XCHG reg16/mem16,reg16       XCHG    AL,[BX]
XCHG reg32/mem32,reg32       XCHG    EAX,EBX
XCHG reg32,reg32/mem32       XCHG    EAX,[EBX]
\end{verbatim}

\section{XLAT / XLATB --- table look-up transLATion}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
XLAT mem8                    XLAT    BYTE ES:[EBX]
XLATB (no arguments)         XLATB
\end{verbatim}

\section{XOR --- logical eXclusive OR}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
XOR reg,reg/mem              XOR     AX,BX
XOR mem,reg                  XOR     [80h],DL
XOR reg/mem,immed            XOR     BYTE [GS:WORD_VAR],18
XOR reg/mem,signed8          XOR     ESI,-6
\end{verbatim}

\section{XORPD --- bitwise logical eXclusive OR for Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
XORPD xmmreg,xmmreg/mem128   XORPD   XMM7,[EAX]
\end{verbatim}

\section{XORPS --- bitwise logical eXclusive OR for Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
XORPS xmmreg,xmmreg/mem128   XORPS   XMM0,[ESI*4]
\end{verbatim}

\include{contact}

\begin{thebibliography}{12}
\bibitem{UFES} Federal University of Esp\'{\i}rito Santo -- ES -- Brazil.
http://www.ufes.br
\bibitem{PUC} Pontificial Catholic University of Rio de Janeiro -- RJ
-- Brazil. http://www.puc-rio.br
\bibitem{SF} SourceForge. http://sorceforge.net
\bibitem{ADV}Advogato. http://www.advogato.com
\bibitem{ADVPRSN}H\'elcio Mello's personal page at Advogato.
http://www.advogato.com/person/helcio
\bibitem{FRESH}FreshMeat. http://www.freahmeat.net
\bibitem{FREITAS}Professor PhD S\'ergio A. A. Freitas.
http://www.inf.ufes.br/\~{}sergio.
\bibitem{AUTOCONF}GNU Autoconf.
http://www.gnu.org/software/autoconf/autoconf.html
\bibitem{AUTOMAKE}GNU Automake.
http://www.gnu.org/software/automake/automake.html
\bibitem{MAKE}GNU Make. http://www.gnu.org/software/make/make.html
\bibitem{FPUMAN}FPU Programming on x86 FPU's
\end{thebibliography}

\end{document}
