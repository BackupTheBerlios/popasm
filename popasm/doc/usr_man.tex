\newcommand{\popasm}{\emph{PopAsm}}
\newcommand{\nasm}{\emph{NASM}}
\newcommand{\tasm}{\emph{TASM}}

\documentclass[a4paper,draft,12pt]{book}
\title{\popasm\ --- The Popular Assembler\\User's Manual}
\author{Helcio B. de Mello}
\date{\today}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\pagenumbering{roman}

\bf{NOTE:} This is but a draft of the \popasm\ User's Manual. The
contents of this document may change as needed, until the release
of the first official full version. Comments on English mistakes
or contents are welcome, given the author's native language is not
English. Please see appendix \ref{CONTACT} for contacting info.

\chapter*{About this document}
This document is part of \popasm, the Popular Assembler Project.
It has been totally written in \LaTeX\ by
\popasm\ author himself.

At the time of this writing, \popasm\ had two manuals:

\begin{itemize}
\item{User's Manual} --- this document. It is aimed to those who wish
to use \popasm, regardless the way
it was developed and its internal implementation. This document also
concerns about instalation procedures.
\item{Programmer's Guide} --- documents \popasm\ source code in
detail. It is recommended to those who
want to read, understand and/or modify \popasm\ sources.
\end{itemize}

Please check which manual is the one intended for your needs.

\chapter*{About the author}
H\'elcio Mello was born in Brazil, in 1979. He has a degree in Computer
Engineering from Federal University of
Espirito Santo -- ES -- Brazil\cite{UFES}, and is curently taking
Computer Science in Pontificial Catholic
University in Rio de Janeiro -- RJ -- Brazil\cite{PUC}. He is expected
to be a Master of Science in 2004.

He joined \emph{Sourceforge}\cite{SF} in December 2001, and then
registered \popasm\ as a \emph{SourceForge}
project. The project was finally open to the Free Software community.
In July 2002, he joined \emph{Advogato}
\cite{ADV,ADVPRSN} and \emph{FreshMeat}\cite{FRESH}

\chapter*{Acknowledgements}
\popasm\ is the result of many months of work. Despite being the
sole author of this project, I would like to
thank everybody that somehow contributed to this project. Among those
are the hundreds of people who have already
visited \popasm\ home page, talked about it with friends, mailed
me for comments, and so on.

I would also like to thank the ones who use \popasm\ and trust it.
I know I can always count on you for
feedback about this project. \emph{Sourceforge} support was crucial, as
it hosts \popasm\ CVS repository,
home page, and so on. Thank you very much.

Special thanks go to my first university, UFES\cite{UFES}, where
I learned the bulk of my computering skills, and
to those classmates and teachers who believed \popasm\ project,
such as professor and PhD S\'ergio Freitas%
\cite{FREITAS}, who decided to adopt \popasm\ as the assembler for
his graduate classes about assembly language.

Last, but not least, I would like to thank my family, friends and God
for what I am now and what I have done so far.

\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage

\pagenumbering{arabic}
\part{Getting Started}
The first chapters of this manual explain what \popasm\ is, how
to compile and install it, and how to run it, changing its default
behavior as needed.

\chapter{Introduction}
\popasm\ stands for ``Popular Assembler''. It is an assembler,
that is, and assembly language compiler\footnote{Technically
speaking, assemblers are not compilers. They translate lines of code
into machine language in a one-to-one basis. Compilers
translate each line of code into several machine instructions. However,
from this point on, this document will use both
terms (compiler and assembler) indistinctly.}. Its objective is to
convert human readable code into machine instructions.
These instructions will then be either executed as binary programs or
linked with other modules (possibly written in
other languages) to yield a computer program.

Many assemblers already exist. Some are free and open source, others
are not. Some will offer you features that others
will not. Some will be suited for your needs, but others will not.
\popasm\ was designed to gather in a single
assembler the best features of the existing assemblers, yet adding its
own improvements and remaining compatible with
existing code as well. As a result, most of your legacy code can be
compiled under \popasm\ without any modifications
at all.

Besides the benefits discussed so far, \popasm\ is a free open
source project written in ANSI C++, which means
that anyone can read its source code, modify, and compile it anywhere
an ANSI C++ compiler is avaiable. Its peculiar
features make it suited for nearly any assembly programming project:

\begin{itemize}
   \item{Huge numbers internal representation} allows assembly-time
expression evaluation in both integer and floating
point format without any practical limit;
   \item{Smart default options} make your code cleaner, without the
redundancy demanded by some other assemblers;
   \item{Top flexibility} gives the developers the choice to use the
infamous ``red tape'' present in some assemblers
or just write the good old raw assembly code;
   \item{Compatibility with existing code} eases migration to
\popasm\ from other assemblers. There is no need to edit your code;
\popasm\ is compatible with \tasm\ and \nasm.
   \item{And more...}
\end{itemize}

Due to the reasons discussed above, this assembler was named the
``Popular Assembler''. The next sections comment the two main
assemblers \popasm\ is compatible with.

\section{Notes on \tasm}
\tasm\ is not free software. It is also DOS/Windows only, and
took some time to get the instructions of the new processors
included. Such delay possibly contributed the creation of macros
that assembled those missing instructions. Nevertheless, there
seems to be lots of code written for \tasm\ around.

\popasm\ is an attempt to offer the advantages discussed throughout
this document without forcing people to rewrite their code by hand
or throw it away. This means that \popasm\ can be seen as a superset
of \tasm\footnote{Actually, only the most used features are supported.
Additional \tasm\ features may be added as users request them.}.
Such major feature may boost people to give \popasm\ a try. If it
is not of their liking, trying \popasm\ did not change their legacy
code anyway, so there's very little to lose.

\section{Notes on \nasm}
\nasm\ is a free and portable assembler, and that's good. It looks
like many people use \nasm\ today, but there are several points
where \nasm\ can be questioned\footnote{The objective of this section
is to comment \nasm\ under technical criteria, not to hurt anyone's
feelings. All free software must be respected, regardless of its
suitability to any project requirements.}.

Besides being incompatible with existing code, \nasm\ does not
provide (due its design) any typechecking feature for variables;
the developer is obliged to remember the type of each variable
himself. Some people may argue that this is not a big problem,
but as a project grows in size, remembering each variable type
may become nearly impossible.

It can be even worse when a team of developers is working on
the same project. Unless they use a rigid (and redundant)
naming scheme, things will get messy quickly. Using such
assembler for small projects (say, less than 1,000 lines of
code) may be an acceptable idea; doing so for a large project
may lead to disaster. C++ or Java are strongly typed languages;
just imagine how it would be if they did not perform type checking...

Another key point is the absence of good assembly-time arithmetics
features, such as huge numbers arithmetics (both integer and floating
point). \popasm\ overcomes such problems as described in this
document. Other points could be mentioned, but the purpose of this
manual is solely to document \popasm\ features, not to point out
problems in other assemblers.

\chapter{Compiling and Installing \popasm}
This chapter explains how to compile and install \popasm\ under
Linux or other UNIX-like platforms and DOS/Windows. If you have
already done that you may skip to the next chapter.

\section{UNIX environments}

This section describes compiling \& installing info under UNIX-like
operating systems (such as Linux).

\subsection{Compiling \popasm\ sources\label{COMPUNIX}}
In order to compile \popasm\ sources, you will need an ANSI C++
compiler and its standard libraries\footnote{For the curious, I
use egcs 2.91.66}. You will also need \popasm\ source code, which
you should already have. If not, please go to
\emph{http://popasm.sourceforge.net/} and download it. You will
get an archive containing the source code to be built.

Unpack it anywhere you like, using the appropriate software (e.g.
if you downloaded a .tar.gz file, you should run
\emph{tar xvzf popasm-x.y.z.tar.gz}, where $x$, $y$ and $z$ are
the version numbers of the package you got). At this point, a
directory containing the source code will be created.

Now, you should enter the directory containing the sources. e.g.
\emph{/tmp/popasm-0.0.1}. Please do not mistake it for something
like \emph{/tmp/popasm-0.0.1/src}. You should be in \popasm\ 
source code root directory, as in the example above.

\popasm\ relies on \emph{Autoconf}\cite{AUTOCONF} and
\emph{Automake}\cite{AUTOMAKE} to probe your system for the
necessary resources and generate the resulting \emph{Makefile}.
This file will tell the \emph{Make}\cite{MAKE} utility how to
compile \popasm\ sources. First, type

\begin{verbatim}
./configure
\end{verbatim}

to perform the necessary checks. If everything is ok, you should have a
\emph{Makefile}. The next step is to compile the sources. Just type

\begin{verbatim}
make
\end{verbatim}

and the \emph{Make} utility will do the rest, but might take a few
minutes. There should be no warnings and no errors. If you got any,
please check whether your compiler is ANSI compliant. If it is,
please let me know (contacting information can be found in appendix
\ref{CONTACT}).

\subsection{Installing \popasm}

There is basically two ways of installing \popasm: either from
the source code or from a RPM file.

\subsubsection{Installing from Source Code}
You should compile \popasm\ as in section \ref{COMPUNIX}. Remain
in the directory where you built \popasm\ and issue the command
(you will need to be \emph{root} to do that):

\begin{verbatim}
make install
\end{verbatim}

This will install the binary file, documentation, etc.

\subsubsection{Installing from RPM files}
The easiest way to install \popasm\ is to use RPM files. Get one from
\emph{http://popasm.sourceforge.net/} if you have not done so yet.
Login as \emph{root} and type:

\begin{verbatim}
rpm -ivh popasm-x.y.z.rpm
\end{verbatim}

replacing $x$, $y$ and $z$ for the appropriate version numbers. That's
it, you're done.

\section{DOS and Windows environments}
To be written.

\subsection{Compiling \popasm\ sources\label{COMPDOS}}
To be written.

\subsection{Installing \popasm}
To be written.

\chapter{Running \popasm\label{CMDLINE}}

The objective of an assembler is to translate assembly language source
files into executable ones. This process is ilustrated in figure \ref{BASICASM}.

\begin{figure}[h]
\begin{center}
\begin{picture}(300, 100)(20,0)
\put (  0, 85){\fbox{Source File 1}}
\put ( 80, 88){\vector(2, -1){50}}
\put (  0, 55){\fbox{Source File 2}}
\put ( 80, 58){\vector(2,  0){50}}
\put ( 30, 25){\vdots}
\put (  0,  0){\fbox{Source File n}}
\put ( 80,  3){\vector(1,  1){50}}
\put (135, 55){\fbox{Assembler}}
\put (200, 58){\vector(2,  0){40}}
\put (245, 55){\fbox{Executable File}}
\end{picture}
\caption{Basic assembly process}
\label{BASICASM}
\end{center}
\end{figure}

However, for large projects it is usually better to assemble each file
separately, and then link their output into the final executable file.
This procedure is sketched in figure \ref{SEPARATEASM}.

\begin{figure}[h]
\begin{center}
\begin{picture}(300, 100)(40,0)
\put (  0, 85){\fbox{Source File 1}}
\put ( 80, 88){\vector(1, 0){30}}
\put (115, 85){\fbox{Assembler}}
\put (180, 88){\vector(1, -1){25}}
\put (  0, 55){\fbox{Source File 2}}
\put ( 80, 58){\vector(1,  0){30}}
\put (115, 55){\fbox{Assembler}}
\put (180, 58){\vector(1,  0){25}}
\put ( 30, 25){\vdots}
\put (  0,  0){\fbox{Source File n}}
\put ( 80,  3){\vector(1,  0){30}}
\put (115,  0){\fbox{Assembler}}
\put (180,  3){\vector(1,  2){25}}
\put (210, 55){\fbox{Linker}}
\put (255, 58){\vector(1,  0){30}}
\put (290, 55){\fbox{Executable File}}
\end{picture}
\caption{Separate assembly process}
\label{SEPARATEASM}
\end{center}
\end{figure}

In this case, the assembler outputs object files (.o or .obj extensions) that
are used by the linker to build the final executable file. Such approach has
the advantage of not reassembling source files that have not changed since the
last build. \emph{Make} utilities such as GNU Make\cite{MAKE} are very useful
in these situations.

As an example, suppose that only \emph{Source File 2} has changed. It is then
reassembled and a new object file for this single source file is created,
overwriting the previous one. This new object file is combined by the linker
with the other ones (which are up to date, because their source files did not
change), yielding the updated version of the executable file. Note that the
files that did not change were not reassembled.

This chapter tackles the usage of \popasm\ under command line. Arguments,
options and environment variables are discussed in detail.

To be continued.

\part{\popasm\ Syntax from the Beginning}

This part documents \popasm\ syntax, starting from the simplest concepts.
Experienced assembly-language programmers are likely to feel compelled to
skip the next few chapters, but are hereby advised not to do so before
reading at least the their introductory paragraphs.

After presenting the basic syntax, its elements are described in great
detail, each in a subsequent chapter. After reading this part, the average
devoloper should be able to use the most common features of \popasm\ easily.

\chapter{Basic Syntax}

One of \popasm's major goals is compatibility with existing code.
\popasm\ syntax is very similar to the ones supported by \tasm\ and
\nasm. This chapter discusses \popasm\ basic syntax. The next chapters
go into more detail in each syntax component (numbers, registers, etc.).

As stated in chapter \ref{CMDLINE}, \popasm\ takes one or more source
files as inputs, each one containing assembly-language statements. These
statements, in turn, have the following general form:

\begin{verbatim}
label:          CMD     arguments               ; comment
\end{verbatim}

where:

\begin{itemize}
\item{\emph{label}} is an identifier that marks an offset into the current
   memory segment, so it can be referenced elsewhere in the code. The colon
   (:) after the label is optional, but recommended, as discussed in section
   \ref{NOTELABEL}.
\item{\emph{CMD}} is either a x86 instruction (such as MOV, ADD, etc.) or a
   \popasm\ internal command (ORG, DB, etc.). Command names are
   case-insensitive (MOV, mov and Mov are all accepted).
\item{\emph{arguments}} is a comma-separated list of arguments for the CMD
   command used in this line. An argument is any sort of \emph{expression}
   (see chapter \ref{EXPR}). Some commands neither require nor accept arguments.
\item{\emph{comment}} is whatever you want to write to make your code easier
   to read and maintain. Comments are placed after a semicolon, and
   \popasm\ ignores them altogether.
\end{itemize}

For example:

\begin{verbatim}
MULTIPLY:       IMUL    CX,BX,5                 ; CX = BX * 5
\end{verbatim}

\noindent is a valid statement. MULTIPLY is a label (followed by the
optional colon), IMUL is a x86 instruction, and CX, BX and 5 are
arguments for the IMUL instruction. The string following the semicolon
is a comment, and is thus ignored.

None of the items above are mandatory, except that you cannot specify
arguments for a command without issuing it first. So,

\begin{verbatim}
                MOV     AX,BX
\end{verbatim}

\noindent is a valid statement, but

\begin{verbatim}
                AX,BX
\end{verbatim}

\noindent is obviously not.

\popasm\ imposes no tabbing restrictions; white spaces and tabs are
ignored. This document uses a 1--17--25--49 tabbing scheme (that is,
labels at column 1, commands at column 17, arguments at column 25 and
comments at column 49).

\section{Notes on labels\label{NOTELABEL}}

Valid labels are strings of letters (a--z or A--Z), digits (0--9) or any
of the following characters:

\begin{center}
\_ @ \$ ?
\end{center}

\noindent except that the first character cannot be a digit, otherwise the
label would be treated as a number, as discussed in chapter \ref{NUMCHAP}.
Also, note that it is not allowed to use \popasm\ reserved words (such as
command names, registers, etc.) as labels.

\popasm\ is by default case-insensitive\footnote{Due to compatibility with
\tasm.}. Such behavior may be changed by command line options and environment
variables (see chapter \ref{CMDLINE}). This document uses uppercase letters.

As already mentioned, the use of a colon after a label is optional,
but recommended. For example, suppose you issue a LODSB command, but
mistype it for LOADSB instead. As a result, the mistyped command would
be treated as an ordinary label, and thus not compiled properly. \nasm\ 
calls these ``orphan labels'', and offers a command line option to
warn you about that.

But let's check the code below:

\begin{verbatim}
I_LOVE_USING_LONG_LABELS_THROUGHOUT_MY_CODE
                LOADSB
                OR      AL,AL
                JNZ     I_LOVE_USING_LONG_LABELS_THROUGHOUT_MY_CODE
\end{verbatim}

The first line is a rather long label, and the developer decided
to place it alone in its line of code. The next line is the mistyped
command. If the developer decides to enable the orphan-label warning,
an annoying message will always bother him, saying the long label
is orphan. Using the colon, this problem is solved.

Another good reason to use the optional colon is to have an additional
mark to make it clear, to the ones reading your code, that the label is,
indeed, a label, instead of, say, a macro name. Of course, this can
also be achieved with an indentation pattern.

Special care should be taken when using a colon after a label that
defines data. The colon should not appear in such circumstances. Please
check chapter \ref{DEFDATA} for a detailed description of this issue.

\chapter{Numbers\label{NUMCHAP}}
\popasm\ accepts numbers in a variety of ways. A number is a sequence
of as many digits as you want\footnote{There is no practical limit to
number sizes in \popasm. If you want to write a 1,000,000-digits long
number, \popasm\ will accept it gladly (well, if you have patience to
type such number...). Some other assemblers are limited to 32-bit
integer operations.} or separators, in any order, except that:

\begin{itemize}
\item{The first digit must be a 0--9 digit\footnote{Note that if the
   first digit is not decimal, \popasm\ (and other assemblers) will treat
   the string as a symbol, not a number. For instance, AH is a register,
   but 0AH is a number (10 in hex notation).}}
\item{All digits must be valid in the number base.} For example, ``3'' is
   not a valid digit in binary notation.
\end{itemize}

A separator is an underline (\_) character that may appear anywhere
among the number digits, except that it cannot be the first character.
They are ignored by \popasm, but help people read long numbers.

Examples:

\begin{itemize}
\item{12345678} is a valid number, because all of its digits are in the
   range 0--9
\item{12\_345\_678} is the same as above. Note how separators play the
   same role as a comma (that is, as a human being would write 12,345,678
   to make it more readable)
\item{12\_34\_5\_67\_\_\_8} also works, and is \emph{exactly} as the
   other two numbers above, despite looking weird and not being very useful.
\item{\_12\_345\_678} is not a number because the first character is not
   a digit.
\item{3241\_7779q} is not an acceptable octal number because ``9'' is not
	a valid digit in octal notation (``q'' here stands for octal. Explained
	later).
\end{itemize}

Typical uses for separators include separating binary fields of bit
records. As an example, let's suppose that a simple communication
protocol uses a byte to encode information about a transmission as
follows:

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{c|l}
\hline Bits & Description\\
\hline
6--7 & Package priority (0--3 range)\\
3--5 & Transmitter's ID (0--7 range)\\
0--2 & Receiver's ID (0--7 range)\\
\hline
\end{tabular}
\caption{Encoding of a simple transmission protocol header}
\end{center}
\end{table}
Thanks to the separators, the programmer can now write:

\begin{verbatim}
                         ; p  snd recv
                MOV     AL,11_000_010_B
\end{verbatim}

That is, a priority $p = 11 (binary) = 3$, a sender whose ID is $snd
= 000 (binary) = 0$ and a receiver whose ID is $recv = 010 (binary)
= 2$ are clearly encoded within AL. More complicated examples may
look messy without separators. The B suffix appended to that
number stands for ``binary'', as discussed in the next section.

\section{Using other bases}
As can be seen in the last example, \popasm\ allows one to specify a
number in many bases simply by appending a suffix. Bases and suffixes
supported by \popasm\ are:

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{c|c|l}
\hline Prefix & Base & Valid digits\\
\hline
b, B, y or Y & Binary (base 2)  & 0--1 \\
o, O, q or Q & Octal (base 8)  & 0--7 \\
d, D, t or T & Decimal (base 10)  & 0--9 \\
h or H & Hex (base 16)  & 0--9, A--F and a--f\protect{\footnotemark}\\
\hline
\end{tabular}
\caption{Prefixes and bases}
\end{center}
\end{table}

\footnotetext{Note, however, that the first digit of an hex number
\emph{must} be in 0--9 range, as explained before.}

There are two other ways of declaring a number as hex:

\begin{itemize}
\item{Using the 0x or 0X prefix}, like in C language. If you use this
   prefix, the hex number that follows it does not need to begin with
   a decimal digit, that is, both 0xA and 0x0A are ok.
\item{Using the \$ prefix}, which may be dangerous. Mistaking -\$70 (-70h)
   with \$-70 (current offset minus 70) will surely lead to disaster.
\end{itemize}

It is important to note that if you do not explicitly specify a number
as binary, octal, decimal or hex, \popasm\ will use the current radix
value, which defaults to 10. That is, unless you specify otherwise, all
numbers will be read in decimal notation. See section \ref{RADIXCMD} if
you want to change the default radix.

\section{Real numbers}
Real numbers can be written in two forms:

\begin{itemize}
\item{The usual dot syntax}, like in 1.23, 3.1416, etc. Note that you can
use alternate bases to write real numbers as well. Eg.: 101.01B (5.25 in binary)
\item{Base and exponent}, as in 6.02e-23 (Avogadro\'{}s constant), 8.13e4 (8130),
etc.
\end{itemize}

Unlike some other assembers, \popasm\ can perform assembly-time operations
on both integer and real numbers. Real numbers have no storage limit either.
\popasm\ has also the advantage of neither rounding nor truncating real numbers.
They have their exact values stored as long as possible.

Another key point is that \popasm\ distinguishes between 0.0 and -0.0, because
they have different encodings.

\subsection{Special numbers}
When converted to binary format, real numbers are encoded in IEEE format, which
is the one used by x86 FPU's. However, some bit patterns have special meaning,
such as NaN's and infinities. The ability of defining such values is very useful
if FPU programming is concerned.

In order to do so, \popasm\ uses the folowing keywords:

\begin{itemize}
\item{INFINITY} --- returns the IEEE encoding for $+\infty$. Because \popasm\ 
supports arithmetics even on such special symbols, -INFINITY can be used to
get $-\infty$ if needed.
\item{QNAN n} --- defines a ``quiet NaN'' that hold value $n$ as part of it (see
\cite{FPUMAN} for details).
\item{SNAN n} --- defines a ``signaling NaN'' that hold value $n$ as part of
it (see \cite{FPUMAN} for details).
\end{itemize}

Note that all of the above symbols, as well as all real numbers, are encoded
differently, depending on the size of the variable that will hold them. For
example, the 32-bit representation for $+\infty$ is obviously different from
its 64-bit counterpart. \popasm\ detects which size to use based on commands
issued previously (eg. if an INFINITY keyword appears after a DQ command, then
its 64-bit encoding will be used).

\chapter{Operators}
\popasm\ can perform several arithmetic operations on numbers and symbols. The
operators currently supported, in increasing order of precedence, are listed in
table \ref{OPTAB}.

Operator precedences are discussed in section \ref{NUMEXPR}.

It is important to note that \popasm\ works with both integer and
real numbers. An operator returns an integer only if all of its
arguments are integers. If at least one of them is real, the result
will be real. All possible combinations are summarized in table
\ref{ARGCOMBTAB}.

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{ccl}
\hline
Precedence & Operator & Description\\
\hline
                   & BYTE & 8-bit qualifier\\
                   & WORD & 16-bit qualifier\\
                   & DWORD & Double WORD --- 32-bit qualifier\\
                   & PWORD & triPle WORD --- 48-bit qualifier\\
                   & FWORD & Far WORD --- Same as PWORD\\
                   & QWORD & Quad WORD --- 64-bit qualifier\\
Lowest             & OWORD & Oct WORD --- 128-bit qualifier\\
                   & TBYTE & Ten-BYTE --- 80-bit qualifier\\
                   & TWORD & Ten-WORD --- Same as TBYTE\protect{\footnotemark}\\
                   & SHORT & 8-bit relative displacement\\
                   & NEAR & 16- or 32-bit relative displacement\\
                   & FAR & 32- or 48-bit relative displacement\\
\hline
                   & OR or $\vert$ & Inclusive or\\
                   & XOR or \^{} & Exclusive or\\
\hline
                   & AND or \& & Boolean AND\\
\hline
                   & + & Addition\\
                   & - (binary) & Subtraction\\
\hline
                   & * & Multiplication\\
                   & / & Division\\
                   & MOD or \% & Remainer (modulus)\\
                   & SHL or $< <$ & Binary Shift left\\
                   & SHR or $> >$ & Binary Shift right\\
                   & SAL and SAR & Arithmetic shifts\\
\hline
                   & NOT or \~{}& One's complement\\
                   & + (unary) & Ignored\\
                   & - (unary) & Negation\\
\hline
                   & : & Segment and offset composition\\
\hline
Highest            & . & Member selection in aggregates (see chapter \ref{AGGRCHAP})\\
\hline
\end{tabular}
\caption{Operators and their precedence}
\label{OPTAB}
\end{center}
\end{table}

\footnotetext{Due to compatibility with \nasm.}

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{cccl}
\hline
Argument 1 & Argument 2 & Result & Example\\
\hline
Integer & Integer & Integer & 3 + 2 = 5\\
Integer & Real & Real & 3 + 2.0 = 5.0\\
Real & Integer & Real & 3.0 + 2 = 5.0\\
Real & Real & Real & 3.0 + 2.0 = 5.0\\
\hline
\end{tabular}
\caption{Argument types combinations}
\label{ARGCOMBTAB}
\end{center}
\end{table}

The next sections provide additional details about each operator.

\section{+ and -}
These operators may be either unary or binary; their unary form
have greater precedence. Unary minus change the sign of an expression.
Unary plus performs no operation and exists for completeness.

\section{AND, OR and XOR}
Bitwise boolean operators. They can only be used with integer arguments
(positive or negative). Because numbers have, in theory, infinite bits
to their left (positive numbers may be left padded with zeroes and
negative numbers can be sign-extended with ones), these operators
are affected by the sign of their arguments. Table \ref{BOOLEX} shows
an example of sign influence on bitwise operations. Tables
\ref{ARGBOOLSIGN1}--\ref{ARGBOOLSIGN3} show all possible combinations
of signs, boolean bitwise operations and the way they affect the resulting
sign.

Due to compatibility with \nasm, ``\&'', ``$\vert$'' and ``\^{}'' are also
supported.

\begin{table}
\begin{center}
\begin{tabular}[h]{lrr}
\hline
           &            Decimal &            Binary\\
\hline
Argument 1 &              $-75$ &  $1\cdots 110101$\\
Argument 2 &               $ 3$ &  $0\cdots 000011$\\
\hline
AND Result &                $1$ &  $0\cdots 000001$\\
OR  Result &               $-9$ &  $1\cdots 110111$\\
XOR Result &              $-10$ &  $1\cdots 110110$\\
\hline
\end{tabular}
\caption{Example of bitwise boolean operations on signed numbers}
\label{BOOLEX}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Positive\\
Negative & Positive & Negative\\
\hline
\end{tabular}
\caption{Relation between AND operator and the sign of its arguments}
\label{ARGBOOLSIGN1}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Negative\\
Negative & Negative & Negative\\
\hline
\end{tabular}
\caption{Relation between OR operator and the sign of its arguments}
\label{ARGBOOLSIGN2}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Negative\\
Negative & Negative & Positive\\
\hline
\end{tabular}
\caption{Relation between XOR operator and the sign of its arguments}
\label{ARGBOOLSIGN3}
\end{center}
\end{table}

\section{/ and MOD}
It is not possible to divide by or get the remainer by zero. Also,
the MOD operator \emph{always} return the result with the same sign
of the first argument. For example, \verb@-23 MOD 7 = -2@ and
\verb@23 MOD -7 = 2@.

\nasm\ operators $//$, $\%$ and $\%\%$ are supported for compatibility
reasons.

\section{SHL and SHR}
These operators \bf{always} perform \bf{binary} shifts (i.e. they treat
their arguments as unsigned numbers in two's complement notation). Do
not mistake an SHL operator for the SHL instruction. In the examples
below, the bits shifted in appear delimited by a separator:

\begin{verbatim}
                MOV     AX,101B                 ; AX = 101B here
                SHL     AX,3                    ; SHL instruction
                ; AX SHL 3 = 101B SHL 3 = 101_000B

                MOV     AX,101B SHL 3           ; same as above

                MOV     BL,-50 SHR 3            ; BL = 25
                ; 11001110 SHR 3 = 000_11001
\end{verbatim}

\nasm\ counterparts for these operators ($< <$ and $> >$) are supported
for compatibility reasons. Note, however, that, like \nasm\ and unlike
ANSI C, such operators in \popasm\ always perform binary shifts. If you
need their arithmetic versions, see next section.

Another point to consider is that binary right shifting negative numbers
require their two's complement value to be known. It is not possible to
perform such calculation without fixing the number size in bits. For
example:

\begin{verbatim}
                MOV     AL,-1 SHR 1             ; AL = 127
                MOV     AX,-1 SHR 1             ; AX = 32767
\end{verbatim}

At first glance (without reading the comments), both instructions load
the same value to their destination registers, but because $-1$ is encoded
as $0FFh$ in 8 bits and as $0FFFFh$ in 16 bits, $-1 \ SHR \ 1$ will yield
different results. The second line can be rewritten as:

\begin{verbatim}
                MOV     AX,BYTE -1 SHR 1        ; AX = 127 now
\end{verbatim}

\noindent in order to get the same result for the first line. If the
operand size is omitted, then \popasm\ will get it from the context. As
in the example before, because AX is a 16-bit register $-1$ is encoded
in 16 bits as well.

\section{SAL and SAR}
These operators \bf{always} perform \bf{arithmetic} shifts. Do not
mistake an SAR operator for the SAR instruction. In the examples
below, the bits shifted in appear delimited by a separator:

\begin{verbatim}
                MOV     AX,5                    ; AX = 5 = 101B here
                SAL     AX,3                    ; SAL instruction
                ; AX SAL 3 = 101B SAL 3 = 101_000B

                MOV     AX,5 SAL 3              ; same as above

                MOV     BL,-50 SAR 3            ; BL = -7
                ; 11001110 SAR 3 = 111_11001
\end{verbatim}

The cautious reader should note that SHL and SAL produce the same
results. SAL is supported for completeness only. Note also that SAR
does not depend on the operand size in bits, as SHR does. Repeating
the example of the last section we have:

\begin{verbatim}
                MOV     AL,-1 SAR 1             ; AL = -1 = 255
                MOV     AX,-1 SAR 1             ; AX = -1 = 65535
\end{verbatim}

\section{NOT}
Performs the one´s complement operation (that is, it toggles all bits
of its argument). \verb@NOT@ is both an instruction and an operator.
For example:

\begin{verbatim}
                MOV     AL,5                    ; AL = 5 = 101B here
                NOT     AL                      ; NOT instruction
                ; AL = NOT 5 = NOT 101B = 11111_010B

                MOV     AL,NOT 5                ; same as above
\end{verbatim}

\nasm\ counterpart for this operator, ``\~{}'', is supported for
compatibility reasons.

\chapter{Registers}
\popasm\ supports all registers present in each x86 CPU, except the ones
added in IA-64 architecture (which will be added in a later version):

\begin{itemize}
\item{8-bit general-purpose registers:} AL, BL, CL, DL, AH, BH, CH and DH
\item{16-bit general-purpose registers:} AX, BX, CX, DX, SP, BP, SI and DI
\item{32-bit general-purpose registers:} EAX, EBX, ECX, EDX, ESP, EBP, ESI and EDI
\item{Segment registers:} CS, DS, ES, FS, GS and SS
\item{Control registers:} CR0, CR2, CR3 and CR4
\item{Debug registers:} DR0 thru DR7
\item{Test registers:} TR3 thru TR7
\item{FPU registers:} ST(0) thru ST(7). ST0 thru ST7 are also accepted for
compatibility with \nasm. ST is an alias for ST(0).
\item{MMX registers:} MM0 thru MM7. MM is an alias for MM0.
\item{XMM registers:} XMM0 thru XMM7. XMM is an alias for XMM0.
\end{itemize}

Register names are case insensitive (i.e. AX, ax, aX and Ax are all the
same thing).

\chapter{Constants}
Constants can be used to make code easier to understand and maintain.
There are two kinds of constants supported by \popasm, which are discussed
in the next sections.

\section{Constant constants}
Constant constants are assembly-time symbols that hold values that cannot
be changed. This may sound redundant at first, because no constant could
change its value anyway, so there would be no reason to say ``constant
constant''.

This kind of constant can be defined by the EQU command. Its syntax is:

\begin{verbatim}
label           EQU     expression
\end{verbatim}

\noindent where:

\begin{itemize}
\item{\emph{label}} is the name of the constant to be defined. It \emph{must not}
   be followed by a colon. Rules for specifying labels can be found in
   section \ref{NOTELABEL}.
\item{\emph{expression}} is \emph{any} sort of expression. Expressions are
explained in chapter \ref{EXPR}.
\end{itemize}

For example:

\begin{verbatim}
LINE_FEED       EQU     0Ah
BIOS_SIGNATURE  EQU     55AAh
MAX_RETRIES     EQU     3
\end{verbatim}

The lines of code above define three constants: LINE\_FEED (equal to 0Ah),
BIOS\_SIGNATURE (equal to 55AAh) and MAX\_RETRIES (equal to 3).

Besides the usual restrictions about defining labels, a constant constant
is not allowed to be redefined. For example:

\begin{verbatim}
MAX_RETRIES     EQU     3                       ; 1st definition
MAX_RETRIES     EQU     4                       ; error! redefined constant
MAX_RETRIES     EQU     3                       ; error! redefined constant
\end{verbatim}

As the third line of the example above shows, constant constants cannot be
redefined even if the value of the new definition is the same as the
previous one.

\section{Variable constants}
Variable constants are constants that can be changed (redefined) in
assembly-time. They can be defined (and redefined) by the $=$ operator.
Despite sounding paradoxal, this makes sense, as the next example shows:

\begin{verbatim}
MAX_RETRIES     =       3
; Normal code comes here

MAX_RETRIES     EQU     10                      ; Redefinition ok.
; Critical code! Must be allowed to retry more times!
\end{verbatim}

That is, the same constant is being used in different parts of the
code. Such freedom may lead to bugs if misused, though. If all constants
are made variable, one may accidentally redefine it thinking he would
be defining a new one.




\chapter{Expressions\label{EXPR}}

An expression may be either a single term or a sequence of terms
connected by operators. A term, in turn, can be a number or a symbol.
This section explains how \popasm\ performs assembly-time arithmetics
and works with numbers.

\section{Numeric expressions\label{NUMEXPR}}

\chapter{Memory references}
Memory references can be specified using square brackets [ ] around an expression.
For instance:

\begin{verbatim}
                MOV     AX,1234
\end{verbatim}

\noindent writes the value $1234$ in AX, but

\begin{verbatim}
                MOV     AX,[1234]
\end{verbatim}

\noindent writes the word pointed to by $1234$ in AX. In this case, DS is used as the
default segment register. If you wanted to use another segment register (say,
ES), you would write:

\begin{verbatim}
                MOV     AX,ES:[1234]
\end{verbatim}

\noindent or

\begin{verbatim}
                MOV     AX,[ES:1234]     ; same as above
\end{verbatim}

This latter form was added for compatibility with \nasm\ and \tasm\ ideal mode.
This document uses the former syntax throughoutly, though.

\section{Weak and strong memory references}
Programmers usually need to store data in variables. Those variables can then
be referenced by their names. For example, if VALUE is a word variable, its
contens can be copied to CX by the following command:

\begin{verbatim}
                MOV     CX,VALUE         ; CX = VALUE's contents
\end{verbatim}

Unfortunately, different assemblers may give different meanings to the line
of code above. \tasm\ behaves as described here, but \nasm\ would place the
variable's offset into CX. Because the name of a variable may be treated both
as its contents and its offset (depending on the assembler being used), such
memory references will be called \bf{weak memory references} in \popasm\ 
documentation.

\popasm\ behaves as described above (a variable's name means its contens, \bf{not}
its offset.) with respect to weak memory references. If you wish to refer to
a variable's offset, you should use the \emph{OFFSET} keyword. The example
above would be rewritten as:

\begin{verbatim}
                MOV     CX,OFFSET VALUE  ; CX = VALUE's offset
\end{verbatim}

On the other hand, a \bf{strong memory reference} is always enclosed within a
pair of matching square brackets. Example:

\begin{verbatim}
                MOV     CX,[VALUE]       ; CX = VALUE's contents
\end{verbatim}

The reader is strongly encouraged to avoid weak memory references, for its
meaning is assembler-dependant. Instead, whenever you refer to a variable's
offset, you should use the \emph{OFFSET} keyword, and whenever you want the
variable's contents, a strong memory reference is the best choice. Doing
that way, your code will rely neither on \popasm's default behavior, nor the
presence/absence of command-line options.

To be continued.

\chapter{Defining data\label{DEFDATA}}
To be written.

\part{\popasm\ Advanced Syntax}
This part presents advanced \popasm\ features, including commands and macros
that one might never use, but are here anyway due to the compatibiliy guideline
that drove \popasm\ so far.

\chapter{Aggregates\label{AGGRCHAP}}
This chapter discusses the three ways a developer may aggregate several data
fields into a single data unit, which can be manipulated easier than disjoint
variables spread everywhere. Another good reason to pack data this way is
that your code will become easier to read and maintain without any execution
performance loss.

\section{STRUCT}
To be written.

\section{UNION}
To be written.

\section{RECORD}
To be written.

\chapter{Macros}
To be written.

\appendix

\chapter{\popasm\ commands}
This chapter is a list of all commands supported by \popasm\ (except machine
instructions, summarized in chapter \ref{INSTSUM}) in alphabetic order. If a
command has already been mentioned before in this manual, it will be quickly
summarized here, along with a reference to where it is detailed.

\section{.RADIX\label{RADIXCMD}}
This command allows the developer to change the default radix of numbers
from the point the command is issued until the next .RADIX command or
end-of-file is found. \popasm\ sets the default radix to 10 at the start
of each pass.

\subsection{Syntax}

\begin{verbatim}
                .RADIX  expression
\end{verbatim}

\noindent where \emph{expression} is a constant integer numeric expression
that evaluates to 2, 8, 10 or 16. \emph{expression} cannot be affected by
.RADIX commands, that is, its default radix is always decimal regardless
of previous commands.

\subsection{Examples}

Our first example writes the same number in binary, using the ``B'' suffix
and the .RADIX command.

\begin{verbatim}
BINARY_NUMBER   DB      11000111B             ; 'B' means binary

                .RADIX  2
                ; Numbers default to be binary from now on

BINARY_NUMBER2  DB      11000111              ; same as above

                .RADIX  10
                ; Numbers default to be decimal again

DECIMAL_NUMBER  DD      11000111              ; decimal!
\end{verbatim}

It is still possible to use other bases when the default radix is not
decimal, but special care should be taken when numbers default to be hex.
In the next example, the developer changes the default radix to be 16
and attempts to define a variable whose value is 12 in decimal.

\begin{verbatim}
                .RADIX  16
                ; Numbers default to be hex from now on

AMBIGUOUS       DD      12D                   ; What does 'D' mean?
DECIMAL_NUMBER  DD      12T                   ; 'T' means decimal
HEX_NUMBER      DD      12                    ; 12h
\end{verbatim}

Note that 'D' is a valid digit in hex notation. This means that ``12D''
is interpreted as ``12Dh'', not 12 in decimal notation. In order to
avoid this ambiguity, \popasm\ also accepts ``T'' as a suffix for
decimal notation. It can be used no matter what the current radix is.
The same remarks hold for the binary suffixes ``B'' and ``Y'': ``11B''
is an hex number when the current radix is 16, but ``11Y'' is always
binary.

To be continued.

\chapter{Instruction Set Summary\label{INSTSUM}}
The purpose of this chapter is to summarize all machine instructions of
all CPU's supported by \popasm\ and their valid syntaxes. The reader
should refer to Intel and AMD documentation for further details.

To be written.

\chapter{Contacting info\label{CONTACT}}

\begin{thebibliography}{12}
\bibitem{UFES} Federal University of Esp\'{\i}rito Santo -- ES -- Brazil.
http://www.ufes.br
\bibitem{PUC} Pontificial Catholic University of Rio de Janeiro -- RJ
-- Brazil. http://www.puc-rio.br
\bibitem{SF} SourceForge. http://sorceforge.net
\bibitem{ADV}Advogato. http://www.advogato.com
\bibitem{ADVPRSN}H\'elcio Mello's personal page at Advogato.
http://www.advogato.com/person/helcio
\bibitem{FRESH}FreshMeat. http://www.freahmeat.net
\bibitem{FREITAS}Professor PhD S\'ergio A. A. Freitas.
http://www.inf.ufes.br/\~{}sergio.
\bibitem{AUTOCONF}GNU Autoconf.
http://www.gnu.org/software/autoconf/autoconf.html
\bibitem{AUTOMAKE}GNU Automake.
http://www.gnu.org/software/automake/automake.html
\bibitem{MAKE}GNU Make. http://www.gnu.org/software/make/make.html
\bibitem{FPUMAN}FPU Programming on x86 FPU's
\end{thebibliography}

\end{document}
