\newcommand{\popasm}{\emph{PopAsm}}
\newcommand{\nasm}{\emph{NASM}}
\newcommand{\tasm}{\emph{TASM}}

\documentclass[a4paper,draft,12pt]{book}
\title{\popasm\ --- The Popular Assembler\\User's Manual}
\author{Helcio B. de Mello}
\date{\today}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\pagenumbering{roman}

\bf{NOTE:} This is but a draft of the \popasm\ User's Manual. The
contents of this document may change as needed, until the release
of the first official full version. Comments on English mistakes
or contents are welcome, given the author's native language is not
English. Please see appendix \ref{CONTACT} for contacting info.

\chapter*{About this document}
This document is part of \popasm, the Popular Assembler Project.
It has been totally written in \LaTeX\ by
\popasm\ author himself.

At the time of this writing, \popasm\ had two manuals:

\begin{itemize}
\item{User's Manual} --- this document. It is aimed to those who wish
to use \popasm, regardless the way
it was developed and its internal implementation. This document also
concerns about instalation procedures.
\item{Programmer's Guide} --- documents \popasm\ source code in
detail. It is recommended to those who
want to read, understand and/or modify \popasm\ sources.
\end{itemize}

Please check which manual is the one intended for your needs.

\include{author}
\include{acks}

\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage

\pagenumbering{arabic}
\part{Getting Started}
The first chapters of this manual explain what \popasm\ is, how
to compile and install it, and how to run it, changing its default
behavior as needed.

\chapter{Introduction}
\popasm\ stands for ``Popular Assembler''. It is an assembler,
that is, and assembly language compiler\footnote{Technically
speaking, assemblers are not compilers. They translate lines of code
into machine language in a one-to-one basis. Compilers
translate each line of code into several machine instructions. However,
from this point on, this document will use both
terms (compiler and assembler) indistinctly.}. Its objective is to
convert human readable code into machine instructions.
These instructions will then be either executed as binary programs or
linked with other modules (possibly written in
other languages) to yield a computer program.

Many assemblers already exist. Some are free and open source, others
are not. Some will offer you features that others
will not. Some will be suited for your needs, but others will not.
\popasm\ was designed to gather in a single
assembler the best features of the existing assemblers, yet adding its
own improvements and remaining compatible with
existing code as well. As a result, most of your legacy code can be
compiled under \popasm\ without any modifications
at all.

Besides the benefits discussed so far, \popasm\ is a free open
source project written in ANSI C++, which means
that anyone can read its source code, modify, and compile it anywhere
an ANSI C++ compiler is available. Its peculiar
features make it suited for nearly any assembly programming project:

\begin{itemize}
   \item{Huge numbers internal representation} allows assembly-time
expression evaluation in both integer and floating
point format without any practical limit;
   \item{Smart default options} make your code cleaner, without the
redundancy demanded by some other assemblers;
   \item{Top flexibility} gives the developers the choice to use the
infamous ``red tape'' present in some assemblers
or just write the good old raw assembly code;
   \item{Compatibility with existing code} eases migration to
\popasm\ from other assemblers. There is no need to edit your code;
\popasm\ is compatible with \tasm\ and \nasm.
   \item{And more...}
\end{itemize}

Due to the reasons discussed above, this assembler was named the
``Popular Assembler''. The next sections comment the two main
assemblers \popasm\ is compatible with.

\section{Notes on \tasm}
\tasm\ is not free software. It is also DOS/Windows only, and
took some time to get the instructions of the new processors
included. Such delay possibly contributed the creation of macros
that assembled those missing instructions. Nevertheless, there
seems to be lots of code written for \tasm\ around.

\popasm\ is an attempt to offer the advantages discussed throughout
this document without forcing people to rewrite their code by hand
or throw it away. This means that \popasm\ can be seen as a superset
of \tasm\footnote{Actually, only the most used features are supported.
Additional \tasm\ features may be added as users request them.}.
Such major feature may boost people to give \popasm\ a try. If it
is not of their liking, trying \popasm\ did not change their legacy
code anyway, so there's very little to lose.

\section{Notes on \nasm}
\nasm\ is a free and portable assembler, and that's good. It looks
like many people use \nasm\ today, but there are several points
where \nasm\ can be questioned\footnote{The objective of this section
is to comment \nasm\ under technical criteria, not to hurt anyone's
feelings. All free software must be respected, regardless of its
suitability to any project requirements.}.

Besides being incompatible with existing code, \nasm\ does not
provide (due its design) any typechecking feature for variables;
the developer is obliged to remember the type of each variable
himself. Some people may argue that this is not a big problem,
but as a project grows in size, remembering each variable type
may become nearly impossible.

It can be even worse when a team of developers is working on
the same project. Unless they use a rigid (and redundant)
naming scheme, things will get messy quickly. Using such
assembler for small projects (say, less than 1,000 lines of
code) may be an acceptable idea; doing so for a large project
may lead to disaster. C++ or Java are strongly typed languages;
just imagine how it would be if they did not perform type checking...

Another key point is the absence of good assembly-time arithmetics
features, such as huge numbers arithmetics (both integer and floating
point). \popasm\ overcomes such problems as described in this
document. Other points could be mentioned, but the purpose of this
manual is solely to document \popasm\ features, not to point out
problems in other assemblers.

\chapter{Compiling and Installing \popasm}
This chapter explains how to compile and install \popasm\ under
Linux or other UNIX-like platforms and DOS/Windows. If you have
already done that you may skip to the next chapter.

\section{UNIX environments}

This section describes compiling \& installing info under UNIX-like
operating systems (such as Linux).

\subsection{Compiling \popasm\ sources\label{COMPUNIX}}
In order to compile \popasm\ sources, you will need an ANSI C++
compiler and its standard libraries\footnote{For the curious, I
use egcs 2.91.66}. You will also need \popasm\ source code, which
you should already have. If not, please go to
\emph{http://popasm.sourceforge.net/} and download it. You will
get an archive containing the source code to be built.

Unpack it anywhere you like, using the appropriate software (e.g.
if you downloaded a .tar.gz file, you should run
\emph{tar xvzf popasm-x.y.z.tar.gz}, where $x$, $y$ and $z$ are
the version numbers of the package you got). At this point, a
directory containing the source code will be created.

Now, you should enter the directory containing the sources. e.g.
\emph{/tmp/popasm-0.0.1}. Please do not mistake it for something
like \emph{/tmp/popasm-0.0.1/src}. You should be in \popasm\ 
source code root directory, as in the example above.

\popasm\ relies on \emph{Autoconf}\cite{AUTOCONF} and
\emph{Automake}\cite{AUTOMAKE} to probe your system for the
necessary resources and generate the resulting \emph{Makefile}.
This file will tell the \emph{Make}\cite{MAKE} utility how to
compile \popasm\ sources. First, type

\begin{verbatim}
./configure
\end{verbatim}

to perform the necessary checks. If everything is ok, you should have a
\emph{Makefile}. The next step is to compile the sources. Just type

\begin{verbatim}
make
\end{verbatim}

and the \emph{Make} utility will do the rest, but might take a few
minutes. There should be no warnings and no errors. If you got any,
please check whether your compiler is ANSI compliant. If it is,
please let me know (contacting information can be found in appendix
\ref{CONTACT}).

\subsection{Installing \popasm}

There is basically two ways of installing \popasm: either from
the source code or from a RPM file.

\subsubsection{Installing from Source Code}
You should compile \popasm\ as in section \ref{COMPUNIX}. Remain
in the directory where you built \popasm\ and issue the command
(you will need to be \emph{root} to do that):

\begin{verbatim}
make install
\end{verbatim}

This will install the binary file, documentation, etc.

\subsubsection{Installing from RPM files}
The easiest way to install \popasm\ is to use RPM files. Get one from
\emph{http://popasm.sourceforge.net/} if you have not done so yet.
Login as \emph{root} and type:

\begin{verbatim}
rpm -ivh popasm-x.y.z.rpm
\end{verbatim}

replacing $x$, $y$ and $z$ for the appropriate version numbers. That's
it, you're done.

\section{DOS and Windows environments}
To be written.

\subsection{Compiling \popasm\ sources\label{COMPDOS}}
To be written.

\subsection{Installing \popasm}
To be written.

\chapter{Running \popasm\label{CMDLINE}}

The objective of an assembler is to translate assembly language source
files into executable ones. This process is ilustrated in figure \ref{BASICASM}.

\begin{figure}[h]
\begin{center}
\begin{picture}(300, 100)(20,0)
\put (  0, 85){\fbox{Source File 1}}
\put ( 80, 88){\vector(2, -1){50}}
\put (  0, 55){\fbox{Source File 2}}
\put ( 80, 58){\vector(2,  0){50}}
\put ( 30, 25){\vdots}
\put (  0,  0){\fbox{Source File n}}
\put ( 80,  3){\vector(1,  1){50}}
\put (135, 55){\fbox{Assembler}}
\put (200, 58){\vector(2,  0){40}}
\put (245, 55){\fbox{Executable File}}
\end{picture}
\caption{Basic assembly process}
\label{BASICASM}
\end{center}
\end{figure}

However, for large projects it is usually better to assemble each file
separately, and then link their output into the final executable file.
This procedure is sketched in figure \ref{SEPARATEASM}.

\begin{figure}[h]
\begin{center}
\begin{picture}(300, 100)(40,0)
\put (  0, 85){\fbox{Source File 1}}
\put ( 80, 88){\vector(1, 0){30}}
\put (115, 85){\fbox{Assembler}}
\put (180, 88){\vector(1, -1){25}}
\put (  0, 55){\fbox{Source File 2}}
\put ( 80, 58){\vector(1,  0){30}}
\put (115, 55){\fbox{Assembler}}
\put (180, 58){\vector(1,  0){25}}
\put ( 30, 25){\vdots}
\put (  0,  0){\fbox{Source File n}}
\put ( 80,  3){\vector(1,  0){30}}
\put (115,  0){\fbox{Assembler}}
\put (180,  3){\vector(1,  2){25}}
\put (210, 55){\fbox{Linker}}
\put (255, 58){\vector(1,  0){30}}
\put (290, 55){\fbox{Executable File}}
\end{picture}
\caption{Separate assembly process}
\label{SEPARATEASM}
\end{center}
\end{figure}

In this case, the assembler outputs object files (.o or .obj extensions) that
are used by the linker to build the final executable file. Such approach has
the advantage of not reassembling source files that have not changed since the
last build. \emph{Make} utilities such as GNU Make\cite{MAKE} are very useful
in these situations.

As an example, suppose that only \emph{Source File 2} has changed. It is then
reassembled and a new object file for this single source file is created,
overwriting the previous one. This new object file is combined by the linker
with the other ones (which are up to date, because their source files did not
change), yielding the updated version of the executable file. Note that the
files that did not change were not reassembled.

This chapter tackles the usage of \popasm\ under command line. Arguments,
options and environment variables are discussed in detail.

To be continued.

\part{\popasm\ Syntax from the Beginning}

This part documents \popasm\ syntax, starting from the simplest concepts.
Experienced assembly-language programmers are likely to feel compelled to
skip the next few chapters, but are hereby advised not to do so before
reading at least the their introductory paragraphs.

After presenting the basic syntax, its elements are described in great
detail, each in a subsequent chapter. After reading this part, the average
devoloper should be able to use the most common features of \popasm\ easily.

\chapter{Basic Syntax}

One of \popasm's major goals is compatibility with existing code.
\popasm\ syntax is very similar to the ones supported by \tasm\ and
\nasm. This chapter discusses \popasm\ basic syntax. The next chapters
go into more detail in each syntax component (numbers, registers, etc.).

As stated in chapter \ref{CMDLINE}, \popasm\ takes one or more source
files as inputs, each one containing assembly-language statements. These
statements, in turn, have the following general form:

\begin{verbatim}
label:          CMD     arguments               ; comment
\end{verbatim}

where:

\begin{itemize}
\item{\emph{label}} is an identifier that marks an offset into the current
   memory segment, so it can be referenced elsewhere in the code. The colon
   (:) after the label is optional, but recommended, as discussed in section
   \ref{NOTELABEL}.
\item{\emph{CMD}} is either a x86 instruction (such as MOV, ADD, etc.) or a
   \popasm\ internal command (ORG, DB, etc.). Command names are
   case-insensitive (MOV, mov and Mov are all accepted).
\item{\emph{arguments}} is a comma-separated list of arguments for the CMD
   command used in this line. An argument is any sort of \emph{expression}
   (see chapter \ref{EXPR}). Some commands neither require nor accept arguments.
\item{\emph{comment}} is whatever you want to write to make your code easier
   to read and maintain. Comments are placed after a semicolon, and
   \popasm\ ignores them altogether.
\end{itemize}

For example:

\begin{verbatim}
MULTIPLY:       IMUL    CX,BX,5                 ; CX = BX * 5
\end{verbatim}

\noindent is a valid statement. MULTIPLY is a label (followed by the
optional colon), IMUL is a x86 instruction, and CX, BX and 5 are
arguments for the IMUL instruction. The string following the semicolon
is a comment, and is thus ignored.

None of the items above are mandatory, except that you cannot specify
arguments for a command without issuing it first. So,

\begin{verbatim}
                MOV     AX,BX
\end{verbatim}

\noindent is a valid statement, but

\begin{verbatim}
                AX,BX
\end{verbatim}

\noindent is obviously not.

\popasm\ imposes no tabbing restrictions; white spaces and tabs are
ignored. This document uses a 1--17--25--49 tabbing scheme (that is,
labels at column 1, commands at column 17, arguments at column 25 and
comments at column 49).

\section{Notes on labels\label{NOTELABEL}}

Valid labels are strings of letters (a--z or A--Z), digits (0--9) or any
of the following characters:

\begin{center}
\_ @ \$ ?
\end{center}

\noindent except that the first character cannot be a digit, otherwise the
label would be treated as a number, as discussed in chapter \ref{NUMCHAP}.
Also, note that it is not allowed to use \popasm\ reserved words (such as
command names, registers, etc.) as labels.

\popasm\ is by default case-insensitive\footnote{Due to compatibility with
\tasm.}. Such behavior may be changed by command line options and environment
variables (see chapter \ref{CMDLINE}). This document uses uppercase letters.

As already mentioned, the use of a colon after a label is optional,
but recommended. For example, suppose you issue a LODSB command, but
mistype it for LOADSB instead. As a result, the mistyped command would
be treated as an ordinary label, and thus not compiled properly. \nasm\ 
calls these ``orphan labels'', and offers a command line option to
warn you about that.

But let's check the code below:

\begin{verbatim}
I_LOVE_USING_LONG_LABELS_THROUGHOUT_MY_CODE
                LOADSB
                OR      AL,AL
                JNZ     I_LOVE_USING_LONG_LABELS_THROUGHOUT_MY_CODE
\end{verbatim}

The first line is a rather long label, and the developer decided
to place it alone in its line of code. The next line is the mistyped
command. If the developer decides to enable the orphan-label warning,
an annoying message will always bother him, saying the long label
is orphan. Using the colon, this problem is solved.

Another good reason to use the optional colon is to have an additional
mark to make it clear, to the ones reading your code, that the label is,
indeed, a label, instead of, say, a macro name. Of course, this can
also be achieved with an indentation pattern.

Special care should be taken when using a colon after a label that
defines data. The colon should not appear in such circumstances. Please
check chapter \ref{DEFDATA} for a detailed description of this issue.

\chapter{Numbers\label{NUMCHAP}}
\popasm\ accepts numbers in a variety of ways. A number is a sequence
of as many digits as you want\footnote{There is no practical limit to
number sizes in \popasm. If you want to write a 1,000,000-digits long
number, \popasm\ will accept it gladly (well, if you have patience to
type such number...). Some other assemblers are limited to 32-bit
integer operations.} or separators, in any order, except that:

\begin{itemize}
\item{The first digit must be a 0--9 digit\footnote{Note that if the
   first digit is not decimal, \popasm\ (and other assemblers) will treat
   the string as a symbol, not a number. For instance, AH is a register,
   but 0AH is a number (10 in hex notation).}}
\item{All digits must be valid in the number base.} For example, ``3'' is
   not a valid digit in binary notation.
\end{itemize}

A separator is an underline (\_) character that may appear anywhere
among the number digits, except that it cannot be the first character.
They are ignored by \popasm, but help people read long numbers.

Examples:

\begin{itemize}
\item{12345678} is a valid number, because all of its digits are in the
   range 0--9
\item{12\_345\_678} is the same as above. Note how separators play the
   same role as a comma (that is, as a human being would write 12,345,678
   to make it more readable)
\item{12\_34\_5\_67\_\_\_8} also works, and is \emph{exactly} as the
   other two numbers above, despite looking weird and not being very useful.
\item{\_12\_345\_678} is not a number because the first character is not
   a digit.
\item{3241\_7779q} is not an acceptable octal number because ``9'' is not
	a valid digit in octal notation (``q'' here stands for octal. Explained
	later).
\end{itemize}

Typical uses for separators include separating binary fields of bit
records. As an example, let's suppose that a simple communication
protocol uses a byte
 to encode information about a transmission as
follows:

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{c|l}
\hline Bits & Description\\
\hline
6--7 & Package priority (0--3 range)\\
3--5 & Transmitter's ID (0--7 range)\\
0--2 & Receiver's ID (0--7 range)\\
\hline
\end{tabular}
\caption{Encoding of a simple transmission protocol header}
\end{center}
\end{table}
Thanks to the separators, the programmer can now write:

\begin{verbatim}
                         ; p  snd recv
                MOV     AL,11_000_010_B
\end{verbatim}

That is, a priority $p = 11 (binary) = 3$, a sender whose ID is $snd
= 000 (binary) = 0$ and a receiver whose ID is $recv = 010 (binary)
= 2$ are clearly encoded within AL. More complicated examples may
look messy without separators. The B suffix appended to that
number stands for ``binary'', as discussed in the next section.

\section{Using other bases}
As can be seen in the last example, \popasm\ allows one to specify a
number in many bases simply by appending a suffix. Bases and suffixes
supported by \popasm\ are:

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{c|c|l}
\hline Prefix & Base & Valid digits\\
\hline
b, B, y or Y & Binary (base 2)  & 0--1 \\
o, O, q or Q & Octal (base 8)  & 0--7 \\
d, D, t or T & Decimal (base 10)  & 0--9 \\
h or H & Hex (base 16)  & 0--9, A--F and a--f\protect{\footnotemark}\\
\hline
\end{tabular}
\caption{Prefixes and bases}
\end{center}
\end{table}

\footnotetext{Note, however, that the first digit of an hex number
\emph{must} be in 0--9 range, as explained before.}

There are two other ways of declaring a number as hex:

\begin{itemize}
\item{Using the 0x or 0X prefix}, like in C language. If you use this
   prefix, the hex number that follows it does not need to begin with
   a decimal digit, that is, both 0xA and 0x0A are ok.
\item{Using the \$ prefix}, which may be dangerous. Mistaking -\$70 (-70h)
   with \$-70 (current offset minus 70) will surely lead to disaster.
\end{itemize}

It is important to note that if you do not explicitly specify a number
as binary, octal, decimal or hex, \popasm\ will use the current radix
value, which defaults to 10. That is, unless you specify otherwise, all
numbers will be read in decimal notation. See section \ref{RADIXCMD} if
you want to change the default radix.

\section{Real numbers}
Real numbers can be written in two forms:

\begin{itemize}
\item{The usual dot syntax}, like in 1.23, 3.1416, etc. Note that you can
use alternate bases to write real numbers as well. Eg.: 101.01B (5.25 in binary)
\item{Base and exponent}, as in 6.02e-23 (Avogadro\'{}s constant), 8.13e4 (8130),
etc.
\end{itemize}

Unlike some other assembers, \popasm\ can perform assembly-time operations
on both integer and real numbers. Real numbers have no storage limit either.
\popasm\ has also the advantage of neither rounding nor truncating real numbers.
They have their exact values stored as long as possible.

Another key point is that \popasm\ distinguishes between 0.0 and -0.0, because
they have different encodings.

\subsection{Special numbers\label{SPECNUMSEC}}
When converted to binary format, real numbers are encoded in IEEE format, which
is the one used by x86 FPU's. However, some bit patterns have special meaning,
such as NaN's and infinities. The ability of defining such values is very useful
if FPU programming is concerned.

In order to do so, \popasm\ uses the folowing keywords:

\begin{itemize}
\item{INFINITY} --- returns the IEEE encoding for $+\infty$. Because \popasm\ 
supports arithmetics even on such special symbols, -INFINITY can be used to
get $-\infty$ if needed.
\item{QNAN n} --- defines a ``quiet NaN'' that hold value $n$ as its fraction.
$n$ must not be zero (see \cite{FPUMAN} for details).
\item{SNAN n} --- defines a ``signaling NaN'' that hold value $n$ as its fraction.
$n$ must not be zero (see \cite{FPUMAN} for details).
\end{itemize}

Note that all of the above symbols, as well as all real numbers, are encoded
differently, depending on the size of the variable that will hold them. For
example, the 32-bit representation for $+\infty$ is obviously different from
its 64-bit counterpart. \popasm\ detects which size to use based on commands
issued previously (eg. if an INFINITY keyword appears after a DQ command, then
its 64-bit encoding will be used).

The next example shows how those keywords can be used:

\begin{verbatim}
                DD      INFINITY                ;  7F80_0000h
                DQ      -INFINITY               ; 0FFE0_0000_0000_0000h
                DD      QNAN 5                  ;  7FC0_0005h
                DQ      -SNAN 18                ; 0FFE0_0000_0000_0012h
                DD      QNAN 0                  ; Error! QNaN being zero
\end{verbatim}

\chapter{Operators}
\popasm\ can perform several arithmetic operations on numbers and symbols. The
operators currently supported, in increasing order of precedence, are listed in
table \ref{OPTAB}.

Operator precedences are discussed in section \ref{NUMEXPR}.

It is important to note that \popasm\ works with both integer and
real numbers. An operator returns an integer only if all of its
arguments are integers. If at least one of them is real, the result
will be real. All possible combinations are summarized in table
\ref{ARGCOMBTAB}.

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{ccl}
\hline
Precedence & Operator & Description\\
\hline
                   & BYTE & 8-bit qualifier\\
                   & WORD & 16-bit qualifier\\
                   & DWORD & Double WORD --- 32-bit qualifier\\
                   & PWORD & triPle WORD --- 48-bit qualifier\\
                   & FWORD & Far WORD --- Same as PWORD\\
                   & QWORD & Quad WORD --- 64-bit qualifier\\
Lowest             & OWORD & Oct WORD --- 128-bit qualifier\\
                   & TBYTE & Ten-BYTE --- 80-bit qualifier\\
                   & TWORD & Ten-WORD --- Same as TBYTE\protect{\footnotemark}\\
                   & SHORT & 8-bit relative displacement\\
                   & NEAR & 16- or 32-bit relative displacement\\
                   & FAR & 32- or 48-bit relative displacement\\
\hline
                   & OR or $\vert$ & Inclusive or\\
                   & XOR or \^{} & Exclusive or\\
\hline
                   & AND or \& & Boolean AND\\
\hline
                   & + & Addition\\
                   & - (binary) & Subtraction\\
\hline
                   & * & Multiplication\\
                   & / & Division\\
                   & MOD or \% & Remainer (modulus)\\
                   & SHL or $< <$ & Binary Shift left\\
                   & SHR or $> >$ & Binary Shift right\\
                   & SAL and SAR & Arithmetic shifts\\
\hline
                   & NOT or \~{}& One's complement\\
                   & + (unary) & Ignored\\
                   & - (unary) & Negation\\
\hline
                   & : & Segment and offset composition\\
\hline
Highest            & . & Member selection (see chapter \ref{AGGRCHAP})\\
\hline
\end{tabular}
\caption{Operators and their precedence}
\label{OPTAB}
\end{center}
\end{table}

\footnotetext{Due to compatibility with \nasm.}

\begin{table}[h]
\begin{center}
\begin{tabular}[h]{cccl}
\hline
Argument 1 & Argument 2 & Result & Example\\
\hline
Integer & Integer & Integer & 3 + 2 = 5\\
Integer & Real & Real & 3 + 2.0 = 5.0\\
Real & Integer & Real & 3.0 + 2 = 5.0\\
Real & Real & Real & 3.0 + 2.0 = 5.0\\
\hline
\end{tabular}
\caption{Argument types combinations}
\label{ARGCOMBTAB}
\end{center}
\end{table}

The next sections provide additional details about each operator.

\section{Size specifiers\label{SIZESPECSEC}}
Also known as size qualifiers, these are the BYTE, WORD, DWORD,
etc. operators. They allow the developer to specify or override
the size (in bits) of an expression. For example:

\begin{verbatim}
                ADD     [BX],7                  ; Error! Undefined operand size.
                ADD     BYTE [BX],7             ; Add 7 to the byte pointed to by BX
                ADD     WORD [BX],7             ; Add 7 to the word pointed to by BX
\end{verbatim}

The first line generates an error because \popasm\ has no means to
figure out whether the user wants to refer to the byte, word or
dword pointed to by BX. There would be three different instructions
depending on which size specifier were used.

The next example shows how the size specifiers can be used to override the
size of a variable:

\begin{verbatim}
FAR_POINTER     DW      5678h, 1234h

                LDS     SI,DWORD [FAR_POINTER]  ; DS:SI = 1234h:5678h
\end{verbatim}

As can be seen, the \verb@FAR_POINTER@ variable defines two words. Because
\popasm\ provides a type checking mechanism, the LDS instruction will check
whether its second argument is a dword variable. In the example above,
\verb@FAR_POINTER@ is defined as a word, and thus there would be a type
mismatch. To tell \popasm\ you are doing so intentionally, use the size
specifier as in the example. This will instruct \popasm\ to treat
\verb@FAR_POINTER@ as a dword.

The reason why \popasm\ behaves like that is to allow the developer to
concentrate on his programming task instead of trying to remember sizes
of variables. Of course, because \popasm\ never forces people to write
code in any particular way, anyone who likes specifying variable sizes
are allowed to do so anytime.

Note that these size specifiers can be used to control the size of
nearly \emph{any} expressions, as shown below.

\begin{verbatim}
                ADD     EDX,18                  ; Adds 18 to EDX
                ADD     EDX,BYTE 18             ; Same as above
                ADD     EDX,DWORD 18            ; 18 encoded as a dword
\end{verbatim}

The first line can be assembled in two ways. One of them encodes 18
as a byte, while the second form encodes 18 as a dword. Because the
first form is more efficient than the second one, and \emph{the
developer did not explicitly choose any in particular}, \popasm\ uses
the former as default.

In fact, as a general rule, everytime the developer does not require
a particular encoding for an instruction, \popasm\ will use its most
efficient form. That's because we understand that if someone needs an
specific encoding, than this need should be emphasised by the size
specifier. Such approach has the following advantages:

\begin{itemize}
\item The developer does not care about \emph{which} encoding will be
used, except under special circumstances where the instruction format
is critical. Because such cases are very rare, the user can benefit
from the efficiency without having to tell the assembler to generate
the short encoding \emph{everytime}.
\item The developer still has full control over his code, because the
longer encoding can be specified, as in the third line of the example
above. It's better to make people use the specifiers only in those
particular cases instead of requiring them to do so everytime (since
most people prefer the efficient form of the instructions).
\item The code will not depend on command line options to be assembled
correctly, since all critical instructions will be shielded from any
such influence by the size specifiers.
\end{itemize}

It's important to note that \popasm\ will \emph{never} replace an
instruction for another one. For instance, \verb@ADD EAX,1@ will
\emph{never} be replaced by an \verb@INC EAX@ instruction.

Due to compatibility reasons, \popasm\ will accept the qualifiers
``BYTE PTR'' as a sinonym for just ``BYTE'', ``WORD PTR'' as well
as just ``WORD'' and so on.

Note that the size specifiers have a slightly
different meaning than their \nasm\ counterparts. If one assembles
the last example using \nasm, \emph{even using the size specifiers}
the encodings are not guaranteed to be size-specific. That's because
\nasm\ supports optimization levels in command line which may ignore
such size specifiers altogether, unless the developer uses the ``STRICT''
keyword. Such keyword is useless in \popasm\ because if someone cares
about specifying the operand size manually that's because this
someone \emph{wants} that particular encoding, regardless of any
optimization level (may be some critical instruction, for example).
Due to compatibility reasons, however, the ``STRICT'' keyword is
recognized, but ignored. Because of the stronger nature of \popasm\
size specifiers there will be no problem in doing so.

%Another point is how \popasm\ handles nesting size qualifiers. In
%this case, the leftmost size qualifier prevails. This may be useful,
%as shown in the next example:
%
%\begin{verbatim}
%VALUE           EQU     BYTE 18
%
%                MOV     ESI,VALUE               ; Error! Size mismatch.
%                MOV     ESI,DWORD VALUE         ; Ok!
%                MOV     ESI,DWORD BYTE 18       ; Same as above
%\end{verbatim}
%
%Initially, \verb@VALUE@ equals 18 as an 8-bit constant. Further in
%the code, such constant must be written in ESI, which is a 32-bit
%5register. Because the constant has explicitly been defined as a
%byte, the first MOV instruction would cause an error. To prevent this,
%the DWORD qualifier tells \popasm\ that such instruction was issued
%intentionally, and thus the constant is sign-extended to 32 bits.
%The last line shows the same nesting explicitly.

\section{+ and -}
These operators may be either unary or binary; their unary form
have greater precedence. Unary minus change the sign of an expression.
Unary plus performs no operation and exists for completeness.

\section{AND, OR and XOR}
Bitwise boolean operators. They can only be used with integer arguments
(positive or negative). Because numbers have, in theory, infinite bits
to their left (positive numbers may be left padded with zeroes and
negative numbers can be sign-extended with ones), these operators
are affected by the sign of their arguments. Table \ref{BOOLEX} shows
an example of sign influence on bitwise operations. Tables
\ref{ARGBOOLSIGN1}--\ref{ARGBOOLSIGN3} show all possible combinations
of signs, boolean bitwise operations and the way they affect the resulting
sign.

Due to compatibility with \nasm, ``\&'', ``$\vert$'' and ``\^{}'' are also
supported.

\begin{table}
\begin{center}
\begin{tabular}[h]{lrr}
\hline
           &            Decimal &            Binary\\
\hline
Argument 1 &              $-75$ &  $1\cdots 110101$\\
Argument 2 &               $ 3$ &  $0\cdots 000011$\\
\hline
AND Result &                $1$ &  $0\cdots 000001$\\
OR  Result &               $-9$ &  $1\cdots 110111$\\
XOR Result &              $-10$ &  $1\cdots 110110$\\
\hline
\end{tabular}
\caption{Example of bitwise boolean operations on signed numbers}
\label{BOOLEX}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Positive\\
Negative & Positive & Negative\\
\hline
\end{tabular}
\caption{Relation between AND operator and the sign of its arguments}
\label{ARGBOOLSIGN1}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Negative\\
Negative & Negative & Negative\\
\hline
\end{tabular}
\caption{Relation between OR operator and the sign of its arguments}
\label{ARGBOOLSIGN2}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}[h]{c|cc}
\hline
         & Positive & Negative\\
\hline
Positive & Positive & Negative\\
Negative & Negative & Positive\\
\hline
\end{tabular}
\caption{Relation between XOR operator and the sign of its arguments}
\label{ARGBOOLSIGN3}
\end{center}
\end{table}

\section{/ and MOD}
It is not possible to divide by or get the remainer by zero. Also,
the MOD operator \emph{always} return the result with the same sign
of the first argument. For example, \verb@-23 MOD 7 = -2@ and
\verb@23 MOD -7 = 2@.

\nasm\ operators $//$, $\%$ and $\%\%$ are supported for compatibility
reasons.

\section{SHL and SHR}
These operators \bf{always} perform \bf{binary} shifts (i.e. they treat
their arguments as unsigned numbers in two's complement notation). Do
not mistake an SHL operator for the SHL instruction. In the examples
below, the bits shifted in appear delimited by a separator:

\begin{verbatim}
                MOV     AX,101B                 ; AX = 101B here
                SHL     AX,3                    ; SHL instruction
                ; AX SHL 3 = 101B SHL 3 = 101_000B

                MOV     AX,101B SHL 3           ; same as above

                MOV     BL,-50 SHR 3            ; BL = 25
                ; 11001110 SHR 3 = 000_11001
\end{verbatim}

\nasm\ counterparts for these operators ($< <$ and $> >$) are supported
for compatibility reasons. Note, however, that, like \nasm\ and unlike
ANSI C, such operators in \popasm\ always perform binary shifts. If you
need their arithmetic versions, see next section.

Another point to consider is that binary right shifting negative numbers
require their two's complement value to be known. It is not possible to
perform such calculation without fixing the number size in bits. For
example:

\begin{verbatim}
                MOV     AL,-1 SHR 1             ; AL = 127
                MOV     AX,-1 SHR 1             ; AX = 32767
\end{verbatim}

At first glance (without reading the comments), both instructions load
the same value to their destination registers, but because $-1$ is encoded
as $0FFh$ in 8 bits and as $0FFFFh$ in 16 bits, $-1 \ SHR \ 1$ will yield
different results. The second line can be rewritten as:

\begin{verbatim}
                MOV     AX,BYTE -1 SHR 1        ; AX = 127 now
\end{verbatim}

\noindent in order to get the same result for the first line. If the
operand size is omitted, then \popasm\ will get it from the context. As
in the example before, because AX is a 16-bit register $-1$ is encoded
in 16 bits as well.

\section{SAL and SAR}
These operators \bf{always} perform \bf{arithmetic} shifts. Do not
mistake an SAR operator for the SAR instruction. In the examples
below, the bits shifted in appear delimited by a separator:

\begin{verbatim}
                MOV     AX,5                    ; AX = 5 = 101B here
                SAL     AX,3                    ; SAL instruction
                ; AX SAL 3 = 101B SAL 3 = 101_000B

                MOV     AX,5 SAL 3              ; same as above

                MOV     BL,-50 SAR 3            ; BL = -7
                ; 11001110 SAR 3 = 111_11001
\end{verbatim}

The cautious reader should note that SHL and SAL produce the same
results. SAL is supported for completeness only. Note also that SAR
does not depend on the operand size in bits, as SHR does. Repeating
the example of the last section we have:

\begin{verbatim}
                MOV     AL,-1 SAR 1             ; AL = -1 = 255
                MOV     AX,-1 SAR 1             ; AX = -1 = 65535
\end{verbatim}

\section{NOT}
Performs the one´s complement operation (that is, it toggles all bits
of its argument). \verb@NOT@ is both an instruction and an operator.
For example:

\begin{verbatim}
                MOV     AL,5                    ; AL = 5 = 101B here
                NOT     AL                      ; NOT instruction
                ; AL = NOT 5 = NOT 101B = 11111_010B

                MOV     AL,NOT 5                ; same as above
\end{verbatim}

\nasm\ counterpart for this operator, ``\~{}'', is supported for
compatibility reasons.

\chapter{Registers}
\popasm\ supports all registers present in each x86 CPU, except the ones
added in IA-64 architecture (which will be added in a later version):

\begin{itemize}
\item{8-bit general-purpose registers:} AL, BL, CL, DL, AH, BH, CH and DH
\item{16-bit general-purpose registers:} AX, BX, CX, DX, SP, BP, SI and DI
\item{32-bit general-purpose registers:} EAX, EBX, ECX, EDX, ESP, EBP, ESI and EDI
\item{Segment registers:} CS, DS, ES, FS, GS and SS
\item{Control registers:} CR0, CR2, CR3 and CR4
\item{Debug registers:} DR0 thru DR7
\item{Test registers:} TR3 thru TR7
\item{FPU registers:} ST(0) thru ST(7). ST0 thru ST7 are also accepted for
compatibility with \nasm. ST is an alias for ST(0).
\item{MMX registers:} MM0 thru MM7. MM is an alias for MM0.
\item{XMM registers:} XMM0 thru XMM7. XMM is an alias for XMM0.
\end{itemize}

Register names are case insensitive (i.e. AX, ax, aX and Ax are all the
same thing).

\chapter{Constants\label{CONSTCHAP}}
Constants can be used to make code easier to understand and maintain.
There are two kinds of constants supported by \popasm, which are discussed
in the next sections.

\section{Defining constant constants}
Constant constants are assembly-time symbols that hold values that cannot
be changed. This may sound redundant at first, because no constant could
change its value anyway, so there would be no reason to say ``constant
constant''.

This kind of constant can be defined by the EQU command. Its syntax is:

\begin{verbatim}
label           EQU     expression
\end{verbatim}

\noindent where:

\begin{itemize}
\item{\emph{label}} is the name of the constant to be defined. It \emph{must not}
   be followed by a colon. Rules for specifying labels can be found in
   section \ref{NOTELABEL}.
\item{\emph{expression}} is \emph{any} sort of expression. Expressions are
explained in chapter \ref{EXPR}.
\end{itemize}

For example:

\begin{verbatim}
LINE_FEED       EQU     0Ah
BIOS_SIGNATURE  EQU     0AA55h
MAX_RETRIES     EQU     3
\end{verbatim}

The lines of code above define three constants: LINE\_FEED (equal to 0Ah),
BIOS\_SIGNATURE (equal to 0AA55h) and MAX\_RETRIES (equal to 3).

Besides the usual restrictions about defining labels, a constant constant
is not allowed to be redefined. For example:

\begin{verbatim}
MAX_RETRIES     EQU     3                       ; 1st definition
MAX_RETRIES     EQU     4                       ; error! redefined constant
MAX_RETRIES     EQU     3                       ; error! redefined constant
\end{verbatim}

As the third line of the example above shows, constant constants cannot be
redefined even if the value of the new definition is the same as the
previous one.

\section{Defining variable constants}
Variable constants are constants that can be changed (redefined) in
assembly-time. They can be defined (and redefined) by the $=$ operator.
Despite sounding paradoxal, this makes sense, as the next example shows:

\begin{verbatim}
MAX_RETRIES     =       3
; Normal code comes here

MAX_RETRIES     =       10                      ; Redefinition ok.
; Critical code! Must be allowed to retry more times!
\end{verbatim}

That is, the same constant is being used in different parts of the
code. Such freedom may lead to bugs if misused, though. If all constants
are made variable, one may accidentally redefine it thinking he would
be defining a new one. Because constant constants cannot be redefined,
you will get an error message if you forget about an existing constant
and attempt to redefine it. In short: always use constant constants,
unless you need to redefine it later.

\section{Using constants}
Once a constant is defined, it can be used the way anyone would expect,
as shown below:

\begin{verbatim}
FOO             EQU     5

                MOV     AL,5                    ; AL = 5
                MOV     AL,FOO                  ; Same as above
\end{verbatim}

Note that constants may hold expressions, not just numbers. Let's check
the next example:

\begin{verbatim}
; Stack image of SI register after a PUSHA instruction
STACK_SI        EQU     WORD [BP+2]

                PUSHA                           ;
                MOV     STACK_SI,17h            ; SI = 17h
                POPA                            ;
\end{verbatim}

As can be seen, the MOV instruction altered the contents of the SI
register image in the stack, using the STACK\_SI constant. When \popasm\ 
finds the MOV instruction, it replaces the constant's contents and
assemble the instruction normally.

Another key point is that, because \popasm\ is a multi-pass assembler,
users can reference constants that are defined later on. However, when
dealing with variable constants, special care should be taken. For example:

\begin{verbatim}
                MOV     AL,FOO                  ; AL = 5 or 6?

FOO             =       5
                MOV     BL,FOO                  ; BL = 5

FOO             =       6
                MOV     CL,FOO                  ; CL = 6
\end{verbatim}

That is, when referencing a variable constant that has not been defined yet,
\popasm\ uses the value of the first definition (in this case 5). So, in the
first line above FOO equals to 5.

\chapter{Expressions\label{EXPR}}

An expression may be either a single term or a sequence of terms
connected by operators. A term, in turn, can be a number or a symbol.
This section explains how \popasm\ performs assembly-time arithmetics
and works with expressions.

\section{Numeric expressions\label{NUMEXPR}}
As mentioned in chapter \ref{NUMCHAP}, \popasm\ internally stores numbers
using as many bits as necessary to hold them. As a consequence, the
expression evaluation in \popasm\ benefits from this facility. \popasm\ 
also delays number rounding and truncation as much as possible, avoiding
precision losses and overflows.

For example:

\begin{verbatim}
                MOV     AL,17014018740175480164581h MOD 100h
\end{verbatim}

\noindent is a valid \popasm\ statement, because the expression on the
second argument of the MOV instruction evaluates to 81h, which lies in
the 00h-FFh range, and thus can be written into AL. Note that the first
term of the expression is clearly larger than the 32-bit maximum value,
and could cause an overflow in other assemblers.

Numeric terms may be either numbers or numeric constants (see chapter
\ref{CONSTCHAP}). Also, operators execute in decreasing order of precedence.
If two or more operators have the same precedence, they are executed from
left to right. If necessary, parenthesis may be used to alter the evaluation
sequence. There is no limit for parenthesis nesting. See table \ref{OPTAB}
for a list of operators and their precedences.

The code below shows some examples of expression evaluation.

\begin{verbatim}
FOO             EQU     -37
BAR             EQU      7
MINUS_ONE       EQU     -1

; MINUS_ONE is always equal to -1, but -1 is encoded as 0FFh, 0FFFFh, etc.
; depending on the operand size expected. That is, -1 = 0FFh for the DB
; command, -1 = 0FFFFh for the DW command and so on.
                DB      MINUS_ONE >> 4          ; 0Fh
                DW      MINUS_ONE >> 4          ; 0FFFh
                DD      MINUS_ONE >> 4          ; 0FFF_FFFFh
                DQ      MINUS_ONE >> 4          ; 0FFF_FFFF_FFFF_FFFFh

; Arithmetic shift examples. Note that only the final results are
; converted to two's complement.
                DB      FOO SAR 2               ; -10 = 0F6h
                DW      FOO SAR 2               ; -10 = 0FFF6h
                DD      FOO SAR 2               ; -10 = 0FFFF_FFF6h
                DQ      FOO SAR 2               ; -10 = 0FFFF_FFFF_FFFF_FFF6h

; Shows how parenthesis can be used to alter the evaluation sequence.
; Because AL must be in [-128, +127] or [0, 255], we have an error in
; the second line.
                MOV     AL,-FOO + 5 * BAR       ; AL = 6
                MOV     AL,(FOO + 5) * BAR      ; AL = -182 <- Error!

; Signed and unsigned division. -37 = 219 because BL is 8 bits wide.
                MOV     BL,FOO / 5              ; BL = -7 = 0F9h
                MOV     BL,FOO // 5             ; BL = 43

; Same as above, but -37 = 65499 because BX is 16 bits wide.
                MOV     BX,FOO / 5              ; BX = -7 = 0FFF9h
                MOV     BX,FOO // 5             ; BX = 13099

; Signed and unsigned remainer. -37 = 219 because BL is 8 bits wide.
; In the fourth line, -5 = 251
                MOV     BL,FOO % 5              ; BL = -2 = 0FEh
                MOV     BL,FOO %% 5             ; BL = 4
                MOV     BL,-FOO % -5            ; BL = 2
                MOV     BL,-FOO %% -5           ; BL = 219
\end{verbatim}

\section{Memory references}
Memory references can be specified using square brackets [ ] around an expression.
For instance:

\begin{verbatim}
                MOV     AX,[1234]
\end{verbatim}

\noindent writes the word pointed to by $1234$ into AX. In this case, DS is used as the
default segment register. If you wanted to use another segment register (say,
ES), you would write:

\begin{verbatim}
                MOV     AX,ES:[1234]
                MOV     AX,[ES:1234]            ; same as above
\end{verbatim}

This latter form was added for compatibility with \nasm\ and \tasm\ ideal mode.
This document uses the former syntax throughoutly, though.

\subsection{Weak and strong memory references}
Programmers usually need to store data in variables. Those variables can then
be referenced by their names. For example, if VAR is a word variable, its
contens can be copied into CX by the following command:

\begin{verbatim}
                MOV     CX,VAR                  ; CX = VAR's contents
\end{verbatim}

Unfortunately, different assemblers may give different meanings to the line
of code above. \tasm\ behaves as described here, but \nasm\ would place the
variable's offset into CX instead. Because the name of a variable may be
treated both as its contents and its offset (depending on the assembler
being used), such memory references will be called \bf{weak memory references}
in \popasm\ documentation.

\popasm\ behaves as described above (a variable's name means its contens, \bf{not}
its offset.) with respect to weak memory references. If you wish to refer to
a variable's offset, you should use the \emph{OFFSET} keyword. The example
above would be rewritten as:

\begin{verbatim}
                MOV     CX,OFFSET VAR           ; CX = VAR's offset
\end{verbatim}

On the other hand, a \bf{strong memory reference} is always enclosed within a
pair of matching square brackets. Example:

\begin{verbatim}
                MOV     CX,[VAR]                ; CX = VAR's contents
\end{verbatim}

The reader is advised to avoid using weak memory references, for their
meaning is assembler-dependant. Instead, whenever you refer to a variable's
offset, you should use the \emph{OFFSET} keyword, and whenever you want to
reference the variable's contents, a strong memory reference is the best
choice. Doing that way, your code will rely neither on \popasm's default
behavior, nor the presence/absence of command-line options.

\subsection{Additional memory references}
\popasm\ has full support to all syntaxes for referencing memory
in both 16- and 32-bit modes. For the next example, \verb@TABLE@ is an
array of words:

\begin{verbatim}
                MOV     AX,[ES:TABLE+BX+SI+10]  ; like NASM
                MOV     AX,ES:TABLE[BX+SI+10]   ; same as above
                MOV     AX,ES:TABLE[BX][SI][10] ; same as above

                MOV     AX,TABLE[4]             ; AX = 3rd word of the array
                MOV     AX,[TABLE+4]            ; same as above
\end{verbatim}

The first three lines perform the same action. The fourth line is accepted
due to compatibility with \tasm, despite looking confusing at first glance.
The fifth line does the same as the fourth one, but looks better.

\popasm\ always encode memory displacements the most efficient way.
Use size qualifiers if you need to change this behavior. For example:

\begin{verbatim}
                MOV     AX,[BX+5]               ; Efficient encoding
                MOV     AX,[BX+BYTE 5]          ; same as above
                MOV     AX,[BYTE BX+5]          ; same as above

                MOV     AX,[BX+WORD 5]          ; Forces 16-bit displacement
                MOV     AX,[WORD BX+5]          ; same as above
\end{verbatim}

The first line encodes the displacement (5) as a byte by default. The
next line does the same thing, as third one, supported because of
compatibility  with \nasm. The next two lines force the displacement
being encoded as a word. 

It is also possible to force a null displacement being encoded as
a byte or word. See the next example:

\begin{verbatim}
                MOV     AX,[BX]                 ; No displacement

                MOV     AX,[BX+BYTE 0]          ; Forces a null 8-bit displacement
                MOV     AX,[BYTE BX]            ; same as above

                MOV     AX,[BX+WORD 0]          ; Forces a null 16-bit displacement
                MOV     AX,[WORD BX]            ; same as above

                INC     BYTE [WORD BX]          ; Increments the byte pointed to by BX. Uses a zero 16-bit displacement.
                INC     BYTE [BX+WORD 0]        ; same as above
                INC     WORD [BYTE BX]          ; Increments the word pointed to by BX. Uses a zero 8-bit displacement.
                INC     WORD [BX+BYTE 0]        ; same as above
\end{verbatim}

The first line has no displacement; the second one forces a zero
dummy displacement being encoded as a byte. The third line does
the same, despite looking weird (supported due to compatibility
with \nasm). The fourth and fifth lines use a null 16-bit dummy
displacement. In 32-bit mode, the displacement may be encoded as
either a byte or a dword.

The last four lines are there as a warning: one must be careful
when using \nasm\ syntax for dummy displacements. The size qualifier
inside the square brackets specify the size of the displacement,
not the size of the variable being referenced.

The next example shows some memory access in 32-bit mode:

\begin{verbatim}
                MOV     AX,TABLE[ECX*2]         ; Encoded as TABLE[ECX+ECX]
                MOV     AX,TABLE[NOSPLIT ECX*2] ; Encoded as TABLE

                MOV     AX,TABLE[ECX+EDX]       ; ECX is base
                MOV     AX,TABLE[EDX+ECX]       ; EDX is base

                MOV     AX,DS:TABLE[EBP+ECX]    ; Optimizeable
                MOV     AX,SS:TABLE[ECX+EBP]    ;

DS:             MOV     AX,TABLE[EBP+ECX]       ; Non-optimizeable

                DS:                             ; Same as above
                MOV     AX,TABLE[EBP+ECX]       ;

\end{verbatim}

The memory reference of the first line is encoded as \verb@TABLE[ECX+ECX]@.
Such behavior can be avoided using the \emph{NOSPLIT} keyword, borrowed from
\nasm, as in the second line.

The third and fourth lines look equal, but there is a slight difference
betwwen them: in the third line, ECX is the base register and EDX is the
index one. In the fourth line, the role of ECX and EDX are exchanged.
Whenever possible, the first register will always be encoded as a base
register and the second one as the index register within the SIB.

The next two lines illustrate an exception to that rule. If EBP is used
as the base register, the default segment register for that memory access
would be SS. Conversely, if ECX is used as the base register, DS will be
the default segment register, allowing the segment prefix in the fifth
line to be skipped. Likewise, in the sixth line, exchanging the order of
the registers inside the brackets will make SS the default segment register,
turning the explicit segment override prefix redundant. By default,
\popasm\ performs such optimizations automatically, but they can be disabled
as shown in Chapter \ref{CMDLINE}.

It is more common, however, to disable such optimization for a single critical
line of code, as in the seventh line, where the segment prefix appears to be
a label\footnote{As with labels, the colon is optionsl.}. Such syntax forces
\popasm\ to write the segment prefix and to leave the registers inside the
brackets in their given order. The eigth and ninth lines show an alternative
way of doing so.

\chapter{Defining data\label{DEFDATA}}
This chapter shows how to allocate static storage for variables and, if
desirable, give them an initial value. The general syntax for definig data
is:

\begin{verbatim}
label:          DEF_CMD expression_list
\end{verbatim}

\noindent where:

\begin{itemize}
\item \verb@label@ is the name of the variable to be defined. It is optional,
as well as the colon following it.
\item \verb@DEF_CMD@ is a definition command (see below).
\item \verb@expression_list@ is a comma-separated sequence of expressions.
Such expressions determine the initial value of the variable. If the developer
wants to define uninitialized data, the special value ``?'' may be used instead.
\end{itemize}

The definition command may be any of the following:

\begin{itemize}
\item DB --- Define Byte: defines 8-bits integer variables.
\item DW --- Define Word: defines 16-bits\footnote{Regardless of whether the assembler
is in 16- or 32-bits mode} integer variables.
\item DD --- Define Double word: defines 32-bits integer or floating point variables.
\item DP --- Define triPle word: defines 48-bit integer variables, often used to store
a 48-bits far pointer (16 bits due to segment; 32 bits due offset).
\item DF --- Define Far word: same as DP. Included in \popasm\ for compatibility with \tasm.
\item DQ --- Define Quadruple word: defines 64-bits integer or floating point variables.
\item DT --- Define Ten bytes: defines a 80-bits floating point variable or an 80-bits
integer packed BCD variable.
\item DO --- Define Octuple word: defines 128-bits XMM data.
\end{itemize}

For example:

\begin{verbatim}
FOO             DB     1, 2, 3
                DW     123 + 456, 1234h, ?, -175
NEGATIVE_ZERO   DD     -0.0
ENTRY_POINT     DD     07C0h:0000h
FAR_ADDRESS     DP     1234h:56789ABCh
HUGE_VALUE      DQ     INFINITY
\end{verbatim}

The first line defines FOO as a byte variable. It allocates three bytes in a row and
assign them the 1, 2 and 3 initial values. The second line defines no variable at all,
but allocates four words just after the last byte defined in the first line. Note that
the third word is undefined and that any numeric expression can be accepted as initial
value. The next line defines a double word (32 bits) variable named NEGATIVE\_ZERO,
initialized to the IEEE representation for -0.0. The fourth and fifth lines define a
double and a triple word , but they store a full pointer instead of a sinple integer.
The last line encodes the IEEE representation for $+\infty$ (see Section \ref{SPECNUMSEC}).

\section{DUP expressions}
Sometimes it is necessary to allocate large amounts of memory. There is a special
operator for that purpose: the \emph{DUP} operator. It can only be used within
definition statements. Its role is to duplicate a sequence of expressions. For example:

\begin{verbatim}
FOO             DB      0, 0, 0, 0, 0           ; 5 null bytes
BAR             DB      5 DUP (0)               ; same as above
\end{verbatim}

The parenthesis surrounding the expression to be duplicated are optional. There is
a pitfall regarding their use, shown below:

\begin{verbatim}
FOO             DB      4 DUP (0, 1)            ; defines 8 bytes
FOO2            DB      0, 1, 0, 1, 0, 1, 0, 1  ; same as above

BAR             DB      4 DUP 0, 1              ; defines 5 bytes
BAR2            DB      0, 0, 0, 0, 1           ; same as above
\end{verbatim}

Note that only the expressions inside parenthesis are duplicated. If they are not
used, the DUP operator will act only on the first one, as showm in defining BAR
variable.

DUP expressions can also be nested:

\begin{verbatim}
                DB      2 DUP (1, 2, 2 DUP 3)   ; defines 8 bytes
                DB      1, 2, 3, 3, 1, 2, 3, 3  ; same as above
\end{verbatim}

\section{Label variables}
It is not necessary to allocate any storage to define a variable. In case one
needs to define a variable wothout reserving any memory space, the keyword
\verb@LABEL@ may be used. Its syntax is:

\begin{verbatim}
VARIABLE_NAME   LABEL   type
\end{verbatim}

\noindent where

\begin{itemize}
\item \verb@VARIABLE_NAME@ is the name of the variable to be defined.
\item \verb@type@ is one of the size specifiers discussed in Section
\ref{SIZESPECSEC}.
\end{itemize}

For example:

\begin{verbatim}
INFO_START      LABEL   BYTE                    ; Marks beginning of INFO
LENGTH          DD      35.8                    ;
WIDTH           DD      12.5                    ; Some stuff here...
HEIGTH          DD      80.1                    ;
INFO_END        LABEL   BYTE                    ; Marks end of INFO

INFO_LENGTH     EQU     INFO_END - INFO_START   ; Total storage for INFO
\end{verbatim}

\section{Reserving storage}
In order to achieve compatibility with \nasm, \popasm\ also supports
the RESB, RESW, ..., etc. directives. They are used in the BSS section
of a module to allocate uninitialized memory. Their syntax is:

\begin{verbatim}
LABEL           RES_CMD qty
\end{verbatim}

\noindent where

\begin{itemize}
\item \verb@LABEL@ is the variable to be defined (optional). It may be
followed by an optional colon.
\item \verb@RES_CMD@ is any of the RESB, RESW, ..., etc. commands.
\item \verb@qty@ is the number of bytes, words, etc. to reserve.
\end{itemize}

For example:

\begin{verbatim}
STACK1          RESD    1024                    ; reserve 1024 dwords
BUFFER          RESB    32768                   ; reserve 32768 bytes
\end{verbatim}

\section{Notes on labels}
One of the greatest features of \popasm\ is its type checking mechanism.
When one defines a variable as a word, the assembler will keep track of
that and will issue error messages when it finds type mismatchs, unless
the developer uses a type specifier (see Section \ref{SIZESPECSEC}) to
explicitly override a variable's type.

Note, however, that in order to achieve compability with \tasm, all
labels followed by the optional colon will be treated as code labels
(that is, a label one can JMP to). For example:

\begin{verbatim}
ENTRY_POINT:    DW      OFFSET FUNCTION         ; Watch out!
ENTRY_POINT2    DW      OFFSET FUNCTION         ; Ok.

                .
                .
                .

                JMP     ENTRY_POINT             ; Disaster!
                JMP     [ENTRY_POINT]           ; Ok.
                JMP     ENTRY_POINT2            ; Better.
\end{verbatim}

The first label, ENTRY\_POINT, is defined as a code label. the JMP
instruction will transfer the CPU execution to its offset, \bf{NOT}
to its contens, unless the square brackets are used. Note that code
labels have no type at all, so if ENTRY\_POINT were a far pointer
instead of a near one the wrong instruction would be generated.

ENTRY\_POINT2 is defined using the recommended syntax. Because no
colon is used, \popasm\ assigns the proper typing info to that
variable, so the last line will generate the correct instruction.

In order to avoid this pitfall, the developer may follow a simple
rule: use the colon \emph{only} if the symbol is a code label.
Because defining such labels does not require a colon, one may
choose not to use it at all.

The reader might wonder why \popasm\ does not keep track of the
typing info even when the colon is used. The reason for that is
that some assemblers did not recognize recent instructions (such
as earlier versions of \tasm.). The developer, then, was forced
to encode some instructions manually. For example, if an assembler
does not recognize the EMMS instruction then someone could encode
it this way:

\begin{verbatim}
SOME_LABEL:     DW      77FFh                   ; EMMS

                .
                .
                .

                JMP     SOME_LABEL              ; Ok.
\end{verbatim}

If \verb@SOME_LABEL@ were treated as an ordinary variable the JMP
instruction would jump to address 0FF77h instead of the desired
target.

\part{\popasm\ Advanced Syntax}
This part presents advanced \popasm\ features, including commands and macros
that one might never use, but are here anyway due to the compatibiliy guideline
that drove \popasm\ so far.

\chapter{Aggregates\label{AGGRCHAP}}
This chapter discusses the three ways a developer may aggregate several data
fields into a single data unit, which can be manipulated easier than disjoint
variables spread everywhere. Another good reason to pack data this way is
that your code will become easier to read and maintain without any execution
performance loss.

\section{STRUCT}
Structures are the simplest aggregates that can be defined. They are a sequence
of data members that are placed in adjacent memory addresses. The syntax for
defining structures is:

\begin{verbatim}
struct_name     STRUCT
FIELD_NAME      DEF_CMD EXPRESSION
FIELD_NAME      DEF_CMD EXPRESSION
.
.
.
FIELD_NAME      DEF_CMD EXPRESSION
ENDS
\end{verbatim}

\noindent where FIELD\_NAME are the names of each field (member), DEF\_CMD is
any of the data defining commands (DB, DW, etc., see Chapter \ref{DEFDATA}) and
EXPRESSION is the default value for the field if it is not specified when the
structure is used (see details further in this section). The ENDS command stands
for ``END Structure''. Also, STRUCT and STRUC are both accepted indistinctly.

For example, let's suppose we want to define a simple structure to hold dates.
Its fields will be month, day and year values:

\begin{verbatim}
DATE_STRUCT     STRUCT
MONTH           DB      6
DAY             DB      5
YEAR            DW      1979
ENDS
\end{verbatim}

Note that the code above defines no data at all; it only defines a structure
that may now be used (instantiated). The syntax for instantiating structure is:

\begin{verbatim}
INSTANCE_NAME   STRUCT_NAME <EXPR1, EXPR2, ..., EXPRN>
\end{verbatim}

The syntax above define a variable named INSTANCE\_NAME, and instantiate the
structure to the expressions given (EXPR1, EXPR2, ..., EXPRN). For example,
if someone wants to use the above structure to define a variable that holds
the date ``Oct 22nd 1977'' then the next line will do it:

\begin{verbatim}
IMPORTANT_DATE  DATE_STRUCT <10, 20 + 2, 1977>
\end{verbatim}

As can be seen, the first expression (10) will be placed in the first field of
the structure (MONTH), the second expression, which evaluates to 22 (just to
remind that any numeric expression can be used, not just numbers), will be copied
to the next field and so on. The original default values of the structure definition
remain unchanged. The next example shows how to use those default values:

\begin{verbatim}
JOHN            DATE_STRUCT <2, 7, 1977>
MARY            DATE_STRUCT <5, 1, 1975>
LINDA           DATE_STRUCT < ,  , 1981>
\end{verbatim}

Here, we define three dates. The last one looks incomplete, but the blanks will
be filled by their default values (MONTH = 6 and DAY = 5). The blank spaces
between the commas and the left angle bracket are optional, but were included
to give the code a better look.

Once a structure is instantiated, its fields can be accessed as any other
variable using the field selection operator (.). Using the structures used
in the last example, one could write \verb@JOHN.MONTH@ to refer to the byte
related to MONTH in JOHN variable. Other examples follow:

\begin{verbatim}
                MOV     AL,[JOHN.DAY]           ; AL = 7

                MOV     BX,OFFSET JOHN.DAY      ; Same as above
                MOV     AL,[BX]                 ;

                MOV     BX,OFFSET JOHN          ;
                MOV     SI,OFFSET DATE_STRUCT.DAY; Same as above
                MOV     AL,[BX+SI]              ;

                MOV     [DATE_STRUCT.DAY],19    ; Wrong!
\end{verbatim}

The first line copies the contents of the DAY field of the JOHN variable
(declared as a DATE\_STRUCT in the previous example) into AL. The same
thing could have been achieved by pointing BX to that field (as in the
second line) and using that register as a pointer to the field. Another
variant of this approach is to use two pointers: one pointing to the
variable being referenced and the other to the desired field address
(relative to the beginning of the structure).

Such a relative address can be got by specifying the name of the structure,
followed by the period, followed by the field name. In the fifth line
of the last example, \verb@DATE_STRUCT.DAY@ returns the offset of the
\verb@DAY@ field relative to the beginning of the structure. Note that
that offset cannot be used to access memory, given it does not point to
any structure in particular. That's why the last line of the example
above is wrong.

As a final remark, because the fields of structures occupy memory addresses
individually, the total size of a structure is the sum of the sizes of all
its fields. This value can be returned by the \verb@SIZE@ keyword. For
example, \verb@SIZE DATE_STRUCT@ returns 4 (DAY and MONTH occupy one byte
each, plus two bytes due to the YEAR field).

\section{UNION\label{SECUNION}}
Unions are like structures, except that all of its fields are placed in the
same memory address. Writing to one of its fields thus modifies all of them,
given the shared memory nature of the union.

The syntax for declaring a union is similar to the one for structures,
except that the \verb@STRUCT@ keyword is replaced for \verb@UNION@. Note,
however, that because unions fields occupy the same memory location it
is possible to specify a default value for \emph{at most} one of their
fields. For example:

\begin{verbatim}
EXAMPLE         UNION
BYTE_FIELD      DB      ?
WORD_FIELD      DW      ?
DWORD_FIELD     DD      1234_5678h
ENDS            ; Yes, unions are ended with ENDS, not ENDU
\end{verbatim}

Unions fields are accessed the same way as the fields of a structure (via
the period operator). The offsets of their fields are referred by the
same means as with structures, but keep in mind that the offset of all
fields are the same as the offset of the union variable itself. Considering
the union defined above:

\begin{verbatim}
INSTANCE        EXAMPLE <, 4321h,>
INSTANCE2       EXAMPLE <, 4321h, 123>          ; Error!

                MOV     AL,INSTANCE.BYTE_FIELD  ; AL = 21h
                MOV     AL,BYTE INSTANCE        ; same as above
                MOV     EAX,INSTANCE.DWORD_FIELD; EAX = 1234_4321h
\end{verbatim}

\noindent That it, the default value for the \verb@DWORD_FIELD@ is used
and then it's least significant word is overriden by the specification of
the second field. The second line is not correct because it attempts to
initialize two fields at the same time, which is not allowed.

Some developers may claim that unions are useless. In fact, one can define
a single variable as the largest field of the union. Then, using size
specifiers it would be possible to access the variable as one with a
different size. For example, let's suppose someone wishes to create a variable
that emulates the EAX register. That could be accomplished this way:

\begin{verbatim}
EMULATED_EAX    DD      0

                MOV     [EMULATED_EAX],EAX
                MOV     WORD [EMULATED_EAX],AX
                MOV     BYTE [EMULATED_EAX],AL
                MOV     BYTE [EMULATED_EAX+1],AH
\end{verbatim}

That is, a single dword emulates EAX and when the AL, AH or AX emulated
counterparts need to be accessed, a size specifier overrides the original
size of the variable. In the last line, the person must also remember to
add 1 to the base offset because AH lies in the second least significant
byte in EAX. Needless to say, this is too error prone. An example of how
structures and unions can be used to provide a safer solution is shown in
Section \ref{NESTSEC}.

\section{RECORD}
To be written.

\section{Nesting Aggregates\label{NESTSEC}}
Aggregates can be nested as well. They behave as a field of the aggregate
that contains them. For example, let's suppose we wish to rewrite the
EAX simulation code (shown in Section \ref{SECUNION}) using nested aggregates.
The EAX register can be seen as the union of a dword (EAX itself), a word
(AX) and two bytes (AH and AL).

The problem is that AH and AL do not share the same storage. Instead, they
should be combined into a 16-bits data unit, which will be one of the fields
of the union. The code below does exactely that.

\begin{verbatim}
; AL and AH must be combined in a 16-bits data unit
AX_STRUCT       STRUCT
SIMULATED_AL    DB      ?
SIMULATED_AH    DB      ?
ENDS

EAX_UNION       UNION
SIMULATED_EAX   DD      ?
SIMULATED_AX    DW      ?
SIMULATED_AH_AL AX_STRUCT       <,>
ENDS

EAX_CLONE       EAX_UNION <0,,>

                MOV     AL,EAX_CLONE.SIMULATED_AH_AL.SIMULATED_AL
                MOV     AH,EAX_CLONE.SIMULATED_AH_AL.SIMULATED_AH
                MOV     AX,EAX_CLONE.SIMULATED_AX
                MOV     EAX,EAX_CLONE.SIMULATED_EAX
\end{verbatim}

The code above first defines a structure to mimic AX lower and upper
bytes. This structure is then used as a field of the \verb@EAX_UNION@,
occupying the same memory space as \verb@SIMULATED_EAX@ itself. Note
that a major drawback of this approach is that the user cannot simply
write \verb@EAX_CLONE.SIMULATED_AL@ because \verb@EAX_UNION@ does not 
have such a field. Instead, it should be written
\verb@EAX_CLONE.AX_STRUCT.SIMULATED_AL@, which is too awkward.

There is a way to remedy that situation, though. If the structure is
defined ``on the fly'' its namespace will merge with the union's one
(for details about namespaces, see Section \ref{NAMESPACESEC}).
The example above can be rewritten as:

\begin{verbatim}
EAX_UNION       UNION
SIMULATED_EAX   DD      ?
SIMULATED_AX    DW      ?

                STRUCT                          ;
SIMULATED_AL    DB      ?                       ; Structure defined
SIMULATED_AH    DB      ?                       ; on the fly
ENDS                                            ;

ENDS

EAX_CLONE       EAX_UNION <,,>

                MOV     AL,EAX_UNION.SIMULATED_AL
                MOV     AH,EAX_UNION.SIMULATED_AH
                MOV     AX,EAX_UNION.SIMULATED_AX
                MOV     EAX,EAX_UNION.SIMULATED_EAX
\end{verbatim}

\section{Namespace considerations\label{NAMESPACESEC}}
As a project grows in size, there are likely to be many variables,
structures and unions defined throughout the code. This implies
that there is a greater probability of name clashes occur (that
is, an attempt to define a symbol whose name is already being
used by another symbol definition).

The reason why many compilers complain about name clashes is to
avoid ambiguity when such names are referenced. Unfortunatelly
some assemblers are just too rigid in this constraint. For
example, consider the code below:

\begin{verbatim}
NAME            DB      'John Adams', 0

STUDENT         STRUCT
NAME            DB      50 DUP (0)
AGE             DB      ?
ENDS

EMPLOYEE        STRUCT
NAME            DB      50 DUP (0)
SALARY          DD      ?
ENDS

CHARLIE         STUDENT <'Charlie Smith', 12>
DAVE            EMPLOYEE <'Dave Thompson', 4000.00>

                MOV     DX,OFFSET NAME
                MOV     DX,OFFSET CHARLIE.NAME
                MOV     DX,OFFSET DAVE.NAME
\end{verbatim}

As can be seen, a variable \verb@NAME@ appears three times there.
It has a stand-alone version (defined as John Adams), and it is
also a field in both structures.

The first MOV instruction copies the offset of \verb@NAME@ to DX,
but which \verb@NAME@? In \popasm, because nothing more has being
said so far, the stand-alone version is used. The second MOV
instruction makes it clear it refers to the field of the \verb@STUDENT@
structure (given \verb@CHARLIE@ is a student in this code). The
third MOV instruction has no ambiguity either, because it specifies
the \verb@NAME@ in question is a field on EMPLOYEE structure.

The code above is accepted by \popasm\ but some other assemblers
claim there is a name clash in that code. The reason why \popasm\ 
sees no ambiguity in the example above is that it defines a separate
namespace for each existing segment, structure, union and record
\footnote{Note, however, that aggregates defined on the fly have
their namespace intentionally merged with the one of the aggregate
that contains it. See Section \ref{NESTSEC}}.

Because \popasm\ must also be compatible with existing code, there
are means to force the use of a global namespace for all symbols. See
Chapter \ref{CMDLINE} for details. The code below illustrates this
problem:

\begin{verbatim}
STUDENT         STRUCT
NAME            DB      50 DUP (0)
AGE             DB      ?
ENDS

                MOV     AX,OFFSET AGE           ; Not good
                MOV     AX,OFFSET STUDENT.AGE   ; Better
\end{verbatim}

The first MOV instruction relies on the fact that \verb@AGE@ lies
in a global namespace. Such a statement would be treated as an
error, unless \popasm\ is configured to use the global namespace.
The second MOV instruction shows the prefered way of doing what
the line before it does in other assemblers.

\chapter{Macros}
This chapter shows how macros can be defined and used. A macro is
like a procedure, but there is a main difference: macros are
expanded (``interpreted'') at assembly time; procedures are
executed at run-time.

Macros can be seen as an implicit way of performing ``cut-and-paste''
of portions of code or data. Some of them are built-in and ready
for use. Others are defined by the developer.

\section{Built-in macros}
The suported built-in macros are described in the next subsections.

\subsection{REPT --- REPeaT}
This macro allows one to repeat a block of statements several times.
It's syntax is:

\begin{verbatim}
REPT n
                Block of statements
ENDM
\end{verbatim}

\noindent where $n$ is the number of times the block of statements
must be repeated. It can be any numeric expression that evaluates to
an integer number greater than or equal to zero. Note that if $n$
equals to zero the block will be ignored. Example:

\begin{verbatim}
REPT 10
                DB      1
                DB      2, 3
ENDM

                DB      10 DUP (1, 2, 3)        ; Same as above
\end{verbatim}

This macro also supports nesting, that is, it is allowed to use REPT
inside another REPT block.

\subsection{TIMES --- repeat $n$ TIMES}
Use this macro to repeat \emph{a single statement} several times.
If you need to repeat several statements use the REPT macro instead.
Its syntax is:

\begin{verbatim}
TIMES n         statement
\end{verbatim}

\noindent where $n$ is the number of times the statement must be
repeated. It can be any numeric expression that evaluates to an
integer number greater or equal to zero. Note that if $n$ equals
to zero the statement will be ignored. Example:

\begin{verbatim}
TIMES 10        DB      1, 2, 3
                DB      10 DUP (1, 2, 3)        ; Same as above
\end{verbatim}


\section{Defining your own macros}
Because \popasm\ is compatible with \tasm\ and \nasm, both syntaxes
for defining macros are supported.

\subsection{\tasm\ syntax}
\subsection{\nasm\ syntax}

\appendix

\chapter{\popasm\ commands}
This chapter is a list of all commands supported by \popasm\ (except machine
instructions, summarized in appendix \ref{INSTSUM}) in alphabetic order. If a
command has already been mentioned before in this manual, it will be quickly
summarized here, along with a reference to where it is detailed.

\section{.RADIX\label{RADIXCMD}}
This command allows the developer to change the default radix of numbers
from the point the command is issued until the next .RADIX command or
end-of-file is found. \popasm\ sets the default radix to 10 at the start
of each pass.

\subsection{Syntax}

\begin{verbatim}
                .RADIX  expression
\end{verbatim}

\noindent where \emph{expression} is a constant integer numeric expression
that evaluates to 2, 8, 10 or 16. \emph{expression} cannot be affected by
.RADIX commands, that is, its default radix is always decimal regardless
of previous commands.

\subsection{Examples}

Our first example writes the same number in binary, using the ``B'' suffix
and the .RADIX command.

\begin{verbatim}
BINARY_NUMBER   DB      11000111B             ; 'B' means binary

                .RADIX  2
                ; Numbers default to be binary from now on

BINARY_NUMBER2  DB      11000111              ; same as above

                .RADIX  10
                ; Numbers default to be decimal again

DECIMAL_NUMBER  DD      11000111              ; decimal!
\end{verbatim}

It is still possible to use other bases when the default radix is not
decimal, but special care should be taken when numbers default to be hex.
In the next example, the developer changes the default radix to be 16
and attempts to define a variable whose value is 12 in decimal.

\begin{verbatim}
                .RADIX  16
                ; Numbers default to be hex from now on

AMBIGUOUS       DD      12D                   ; What does 'D' mean?
DECIMAL_NUMBER  DD      12T                   ; 'T' means decimal
HEX_NUMBER      DD      12                    ; 12h
\end{verbatim}

Note that 'D' is a valid digit in hex notation. This means that ``12D''
is interpreted as ``12Dh'', not 12 in decimal notation. In order to
avoid this ambiguity, \popasm\ also accepts ``T'' as a suffix for
decimal notation. It can be used no matter what the current radix is.
The same remarks hold for the binary suffixes ``B'' and ``Y'': ``11B''
is an hex number when the current radix is 16, but ``11Y'' is always
binary.

To be continued.

\chapter{Instruction Set Summary\label{INSTSUM}}
The purpose of this chapter is to summarize all machine instructions of
all CPU's supported by \popasm\ and their valid syntaxes. The reader
should refer to Intel and AMD documentation for further details.

The conventions adopted here are:

\begin{itemize}
\item immed8 --- an 8-bit immediate value
\item signed8 --- a signed 8-bit immediate value
\item unsigned8 --- an unsigned 8-bit immediate value
\item mem - A memory reference
\item reg - a general purpose register
\item xmmreg - an XMM register
\end{itemize}

\section{AAA - Ascii Adjust after Addition}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAA (No arguments)           AAA
\end{verbatim}

\section{AAD - Ascii Adjust before Division}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAD (No arguments)           AAD
AAD unsigned8                AAD     16
\end{verbatim}

\subsection{Notes}
\popasm\ does not check whether or not the immediate argument for this
instruction is zero.

\section{AAM - Ascii Adjust after Multiply}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAD (No arguments)           AAM
AAD unsigned8                AAM     10h
\end{verbatim}

\section{AAS - ASCII Adjust after Subtraction}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AAS (No arguments)           AAS
\end{verbatim}

\section{ADC - ADd with Carry}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADC reg,reg/mem              ADC     CL,DH
ADC mem,reg                  ADC     [80h],EDX
ADC reg/mem,immed            ADC     [VAR],18
ADC reg/mem,signed8          ADC     EAX,-6
\end{verbatim}

\section{ADD - ADDition}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADD reg,reg/mem              ADD     CL,DH
ADD mem,reg                  ADD     [80h],EDX
ADD reg/mem,immed            ADD     [VAR],18
ADD reg/mem,signed8          ADD     EAX,-6
\end{verbatim}

\section{ADDPD - ADD Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDPD xmmreg,xmmreg/mem128   ADDPD   XMM,XMM1
\end{verbatim}

\section{ADDPS - ADD Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDPS xmmreg,xmmreg/mem128   ADDPS   XMM5,TABLE[ESI]
\end{verbatim}

\section{ADDSD - ADD Scalar Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDSD xmmreg,xmmreg/mem64    ADDSD   XMM5,[EDI+ARRAY]
\end{verbatim}

\section{ADDSS - ADD Scalar Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ADDSS xmmreg,xmmreg/mem32    ADDSS   XMM3,ES:[BX]
\end{verbatim}

\section{AND - logical AND}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
AND reg,reg/mem              AND     AX,BX
AND mem,reg                  AND     [80h],DL
AND reg/mem,immed            AND     BYTE [GS:WORD_VAR],18
AND reg/mem,signed8          AND     ESI,-6
\end{verbatim}

\section{ANDPD - bitwise AND Packed Double-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDPD xmmreg,xmmreg/mem128   ANDPD   XMM7,[EAX]
\end{verbatim}

\section{ANDPS - bitwise AND Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDPS xmmreg,xmmreg/mem128   ANDPS   XMM0,[ESI*4]
\end{verbatim}

\section{ANDNPD - bitwise AND Not Packed Double-precision floating-point values}

\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDNPD xmmreg,xmmreg/mem128  ANDNPD  XMM7,[EAX]
\end{verbatim}

\section{ANDNPS - bitwise AND Not Packed Single-precision floating-point values}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ANDNPS xmmreg,xmmreg/mem128  ANDNPS  XMM0,[ESI*4]
\end{verbatim}


\section{ARPL - Adjust RPL field of segment selector}
\begin{verbatim}
Valid Syntaxes               Example
\end{verbatim}
\vspace{-0.7cm}
\hrulefill
\vspace{-0.3cm}
\begin{verbatim}
ARPL reg16/mem16,reg16       ARPL    AX,[BX]
\end{verbatim}

To be continued.

\include{contact}

\begin{thebibliography}{12}
\bibitem{UFES} Federal University of Esp\'{\i}rito Santo -- ES -- Brazil.
http://www.ufes.br
\bibitem{PUC} Pontificial Catholic University of Rio de Janeiro -- RJ
-- Brazil. http://www.puc-rio.br
\bibitem{SF} SourceForge. http://sorceforge.net
\bibitem{ADV}Advogato. http://www.advogato.com
\bibitem{ADVPRSN}H\'elcio Mello's personal page at Advogato.
http://www.advogato.com/person/helcio
\bibitem{FRESH}FreshMeat. http://www.freahmeat.net
\bibitem{FREITAS}Professor PhD S\'ergio A. A. Freitas.
http://www.inf.ufes.br/\~{}sergio.
\bibitem{AUTOCONF}GNU Autoconf.
http://www.gnu.org/software/autoconf/autoconf.html
\bibitem{AUTOMAKE}GNU Automake.
http://www.gnu.org/software/automake/automake.html
\bibitem{MAKE}GNU Make. http://www.gnu.org/software/make/make.html
\bibitem{FPUMAN}FPU Programming on x86 FPU's
\end{thebibliography}

\end{document}
